module pt;

import sdl, opengl, std.math, std.thread, std.file, std.string;
import std.boehm;

import
  scene.checkerpattern, scene.group, scene.plane, scene.scale,
  scene.sphere, scene.translate, scene.triangle, scene.util,
  scene.color, scene.base, scene.bound;

alias EPS = 0.999;

extern(C) {
  void fastsetup(int xfrom, xto, yfrom, yto, dw, dh, VMState*);
  void fast_light_process(VMState*, int numstates, vec3f* lightpos, void* self);
}

import gd;
gdImagePtr readGd(string fname) {
  auto fdata = readAll fname;
  if (fname.toLower().endsWith ".jpg") return gdImageCreateFromJpegPtr(fdata.(length, ptr));
  if (fname.toLower().endsWith ".png") return gdImageCreateFromPngPtr(fdata.(length, ptr));
  raise-error new Error "Unknown extension in '$fname'! ";
}

class LightStep : CommandHandler {
  vec3f* lightpos;
  int numBasicSteps;
  void init(vec3f* lp, int n) { lightpos = lp; numBasicSteps = n; }
  class LightMergeStep : CommandHandler {
    void process(VMState[] list) {
      for int i <- 0 .. list.length {
        auto sp = &list[i];
        
        if (void*:sp.handler == void*:CommandHandler:this)::
        sp.stream = sp.stream[1..$];
        
        auto res = &sp.(result-stack[result-id - 2]);
        if (res.success && res.reflective-color != vec3f(0)) {
          vec3f lightdir = (*lightpos) - sp.ray.pos;
          float lightdist = |lightdir|;
          lightdir = lightdir.normalized;
          auto norm = res.normal;
          if ((norm * sp.(ray-stack[ray-id - 2].dir)).sum > 0)
            norm = -norm;
          vec3f lightprod = lightdir * norm;
          float lightangle = lightprod.sum;
          
          vec3f resv = vec3f(0);
          auto res2 = sp.result;
          if (lightangle >= 0 && (!res2.success || res2.distance >= lightdist))
            resv = res.reflective-color * vec3f(lightangle);
          
          res.emissive-color += resv;
        }
        using sp mixin(freeResult.replace("!!", "1"));
        using sp mixin(freeRay.replace("!!", "1"));
      }
    }
  }
  LightMergeStep mkMergeStep() { return new LightMergeStep; }
  void process(VMState[] list) {
    // TODO: rewrite
    // fast_light_process(list.ptr, list.length, lightpos, void*:CommandHandler:this);
    // return;
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto res = sp.result;
      if (res.success && res.reflective-color != vec3f(0)) {
<<<<<<< Updated upstream
        auto nspos = sp.ray.(pos + dir * (res.distance * EPS));
=======
        auto nspos = sp.ray.(pos + dir * (res.distance * 0.999));
>>>>>>> Stashed changes
        // writeln "nspos = $(sp.ray.(pos, dir)) @ $(res.distance) = $(nspos), lightpos $(*lightpos)";
        using sp mixin(allocRay);
        vec3f lightdir = ((*lightpos) - nspos).normalized;
        sp.ray.(pos, dir) = (nspos, lightdir);
      } else {
        using sp mixin(allocRay);
        using sp mixin(allocResult);
        sp.stream = sp.stream[numBasicSteps .. $]; // skip
      }
    }
  }
}

import std.random;
IRandom rng;
float randf() { return std.random.base.randf(rng); }
float Crandf(void* p) { auto backup = _esi; _esi = p; float res = std.random.base.randf(rng); _esi = backup; return res; }
void init() {
  rng = getPRNG(23);
  auto dg = onThreadCreation;
  onThreadCreation = new delegate void(void* basep) {
    if (dg) { dg(basep); }
    rng = getPRNG(int:basep);
  };
}

vec3f rand_sphere() {
  vec3f res;
  do res = vec3f(randf() * 2 - 1 # x 3);
  while |res| > 1 { }
  return res.normalized;
}

class JitterRay : SceneObject {
  vec2f delegate() scale;
  SceneObject sup;
  void init(vec2f delegate() s, SceneObject sup) { scale = s; this.sup = sup; }
  void process(VMState[] list) {
    auto sc = scale();
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto ray = sp.ray;
      using sp mixin(allocRay.replace("!!", "1"));
      *sp.ray = *ray;
      sp.ray.dir.x += randf() * sc.x;
      sp.ray.dir.y += randf() * sc.y;
    }
  }
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.rays-needed-cur ++;
    auto stream = sup.buildCommandStream(stats);
    stats.rays-needed-cur --;
    return CommandHandler[]:null ~ this ~ stream ~ new FreeRay;
  }
}

class PathTraceStep : CommandHandler {
  int skip, res-delta;
  void init(int s, int rd = 0) { skip = s; res-delta = rd; } 
  class PathTraceMergeStep : CommandHandler {
    void process(VMState[] list) {
      for int i <- 0 .. list.length {
        auto sp = &list[i];
        
        if (void*:sp.handler == void*:CommandHandler:this)::
        sp.stream = sp.stream[1..$];
        
        auto res = &sp.(result-stack[result-id - 2]);
        if (res.success) {
          auto res2 = sp.result;
          if (res2.success) {
            res.emissive-color += res.reflective-color * res2.emissive-color;
          }
        }
        using sp mixin(freeResult.replace("!!", "1"));
      }
    }
  }
  auto mkMergeStep() { return new PathTraceMergeStep; }
  void process(VMState[] list) {
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(allocRay);
      
      auto res = sp.(result-stack[result-id - 1 - res-delta]);
      if (res.success && res.reflective-color != vec3f(0)) {
<<<<<<< Updated upstream
        auto nspos = sp.(ray-stack[ray-id - 2]).(pos + dir * (res.distance * EPS));
=======
        auto nspos = sp.(ray-stack[ray-id - 2]).(pos + dir * (res.distance * 0.999));
>>>>>>> Stashed changes
        // writeln "nspos = $(ray.(pos, dir)) @ $(res.distance) = $(nspos)";
        sp.ray.(pos, dir) = (nspos, rand_sphere());
        auto norm = res.normal;
        if ((norm * sp.(ray-stack[ray-id - 1].dir)).sum >= 0) norm = -norm;
        if (sp.ray.dir * norm).(x+y+z) < 0 sp.ray.dir = -sp.ray.dir;
      } else {
        using sp mixin(allocResult);
        sp.stream = sp.stream[skip .. $]; // no point
      }
    }
  }
}

alias atoi = std.string.atoi;

class LightSource : SceneObject {
  SceneObject sup;
  vec3f* ls;
  void init(vec3f* ls, SceneObject sup) this.(ls, sup) = (ls, sup);
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.results-needed-cur ++;
    stats.rays-needed-cur ++;
    auto stream = sup.buildCommandStream(stats);
    stats.results-needed-cur --;
    stats.rays-needed-cur --;
    using new LightStep(ls, stream.length)
      return stream ~ that ~ stream ~ mkMergeStep();
  }
}

class PathTraceLighting : SceneObject {
  SceneObject sup, sup2; int avg;
  void init(SceneObject sup) this.(sup, sup2, avg) = (sup, sup, 1);
  void init(SceneObject sup, sup2) this.(sup, sup2, avg) = (sup, sup2, 1);
  void init(int avg, SceneObject sup) this.(sup, sup2, avg) = (sup, sup, avg);
  void init(int avg, SceneObject sup, sup2) this.(sup, sup2, avg) = (sup, sup2, avg);
  CommandHandler[] buildCommandStream(VMStats* stats) {
    auto stream = sup.buildCommandStream(stats);
    
    CommandHandler[auto~] res;
    res ~= stream; // results ++
    if (avg == 1) {
      stats.rays-needed-cur ++;
      auto stream2 = sup2.buildCommandStream(stats);
      stats.rays-needed-cur --;
      using new PathTraceStep(stream.length) {
        res ~= that; // rays ++
        res ~= stream2; // results ++
        res ~= new FreeRay; // rays --
        res ~= mkMergeStep(); // results --;
      }
      // summary: neutral
    } else {
      int base-id = stats.results-needed-cur;
      stats.rays-needed-cur ++;
      stats.results-needed-cur ++;
      auto stream2 = sup2.buildCommandStream(stats);
      stats.results-needed-cur --;
      stats.rays-needed-cur --;
      auto pt = new PathTraceStep(stream.length, 1 /* skip one result (our empty averager) */);
      auto fr = new FreeRay;
      auto as = new AverageStep (avg, base-id, base-id + 1);
      auto fs = new FreeResult;
      res ~= new AllocEmptyResult; // results ++
      for (int i = 0; i < avg; ++i) {
        res ~= pt; // rays ++
        res ~= stream2; // results ++
        res ~= fr; // rays --
        res ~= as;
        res ~= fs; // results --
      }
      res ~= pt.mkMergeStep(); // results --
      // neutral
    }
    return res[];
  }
}

import std.time, std.file;
import c.fenv;
extern(C) { void GC_disable(); void GC_gcollect(); void GC_enable(); }
extern(C) int feenableexcept(int);
void main(string[] args) {
  (string exec, args) = args[(0, 1..$)];
  bool break-on-float-errors = true;
  void check() {
    if (!(mxcsr & (1 << 15))) {
      writeln "Oops! FTZ has gotten 0. Resetting. $(mxcsr)";
      // _interrupt 3;
      // rtz, fz
      mxcsr |= (3 << 13) | (1 << 15);
      if (break-on-float-errors)
        for auto val <- [FE_DIVBYZERO, FE_INVALID/*, FE_OVERFLOW .. infs are fine*/]
          feenableexcept val;
    }
  }
  initBoehm (debugMode => true);
  
  onResize = delegate void(int w, int h) {
    screen(w, h, flags => SDL_OPENGL | SDL_RESIZABLE | SDL_ANYFORMAT);
  };
  
  SceneObject scene;
  SceneObject object;
  float lowest = 0;
  using new Group {
    auto bb = new BoxBound that;
    alias objfile = "hikone.obj";
    auto obj = string: import(objfile) #.split "\n";
    alias mtlfile = objfile.replace(".obj", ".mtl");
    auto mtl = string: import(mtlfile) #.split "\n";
    
    (string, void*)[auto~] matcache;
    void* lookupMatl(string matname) {
      for (string name, void* data) <- matcache if name == matname return data;
      bool inSection;
      auto firstmatch = "newmtl $matname";
      string fname;
      for auto line <- mtl {
        if (line.startsWith "newmtl ") {
          inSection = false;
          if (line == firstmatch) inSection = true;
        }
        
        if (inSection && string rest = line.startsWith "map_Kd ") fname = rest;
      }
      if (!fname) {
        writeln "No texture found for $matname! ";
        return null;
      } else {
        auto data = readGd fname;
        writeln "Read image: $matname => $fname";
        if (data) writeln "($(data.sx), $(data.sy))";
        matcache ~= (matname, void*:data);
        return data;
      }
    }
    
    alias mew = string;
    string[] selectAs(string delegate(string) dg) {
      string[auto~] res;
      for auto line <- obj if auto thing = dg line res ~= thing;
      return res[];
    }
    string[] selectOn(bool delegate(string) dg) {
      string[auto~] res;
      for auto line <- obj if dg line res ~= line;
      return res[];
    }
    vec3f vec3f_and_free(float[] array) { onSuccess array.free; return vec3f(array[(0, 1, 2)]); }
    vec2f vec2f_and_free(float[] array) { onSuccess array.free; return vec2f(array[(0, 1)]); }
    auto vertices = [for array <- [auto~for v <- selectAs(delegate string(string s) return s.startsWith "v ";): [auto~for part <- v.split " ": std.string.atof part].eval[]]: vec3f_and_free array].eval[];
    auto texcoords = [for array <- [auto~for v <- selectAs(delegate string(string s) return s.startsWith "vt ";): [auto~for part <- v.split " ": std.string.atof part].eval[]]: vec2f_and_free array].eval[];
    onSuccess { vertices.free; texcoords.free; }
    auto fusemtl = selectOn(delegate bool(string s) return eval s.startsWith "f " || s.startsWith "usemtl "; );
    void* currentTexture;
    auto currentSet = new TriangleSet;
    void flush() {
      writeln "aabb = $(currentSet.root.aabb.a), $(currentSet.root.aabb.b)";
      if (currentSet.root.aabb.a.y < lowest) lowest = currentSet.root.aabb.a.y;
      currentSet.optimize;
      writeln "Tree optimized";
      list ~= currentSet;
      bb.addBox(currentSet.root.aabb.(a, b));
      currentSet = new TriangleSet;
    }
    for auto line <- fusemtl {
      if auto rest = line.startsWith "f " {
        auto poly = rest.split " ";
        if (poly.length > 2)::
        auto tupAndFree(string[] st) { onSuccess st.free; return st[(0, 1)]; }
        auto indices = [for
          pair <- [for pair <- [for part <- poly: delegate auto(string[] st) { onSuccess st.free; return st[(0, 1)]; } part.split "/"]: (std.string.atoi pair[0] - 1, std.string.atoi pair[1] - 1)]:
          (vertices[pair[0]], texcoords[pair[1]])
        ].eval[];
        for (int i = 2; i < poly.length; ++i)
          currentSet.addTriangle (indices[(0, i, i-1)], currentTexture);
        if (currentSet.root.info.length > 1024)
          flush;
        indices.free;
        poly.free;
      }
      if auto rest = line.startsWith "usemtl " {
        currentTexture = lookupMatl rest;
      }
    }
    flush;
    obj.free;
    mtl.free;
    writeln "$(that.list.length) sub-objects";
    // writeln "$(infos.length) tris. ";
    object = bb;
  }
  using new Group {
    // list ~= new CheckerPattern(vec3f(0, 1, 0), vec3f(0, 0, 1), new Plane(vec3f(0, 1, 0), vec3f(0, 0, 0)));
    list ~= new Scale(1/10.0, new CheckerPattern(vec3f(1, 0.95, 0.8), vec3f(0.8, 0.95, 1), new Plane(vec3f(0, 1, 0), vec3f(0, 0, 0))));
    list ~= new Shine(vec3f(1.2, 1.23, 1.3), new Plane(vec3f(0, -1, 0), vec3f(0, 100, 0)));
    // list ~= new Translate(vec3f(0, 0, 5), new Scale(0.2, new CheckerPattern(vec3f(0, 1, 0), vec3f(1, 0, 0), new Sphere(vec3f(0, 0, 0), 10))));
    // list ~= new Translate(vec3f(0, 0, 5), new Scale(2.5, new Triangle(vec3f(-1, 0.1, -1), vec3f(-1, 0.1, 1), vec3f(1, 0.1, -1))));
    list ~= new Translate(vec3f(1, -lowest / 25, 5), new Scale(vec3f(-1/25.0, 1/25.0, -1/25.0), object));
    scene = that;
  }
  
  vec3f lightpos;
  
  float desired-fps = 1;
  for auto arg <- args if auto rest = arg.startsWith "-fps=" desired-fps = std.string.atof rest;
  float lightrot = 1.43;
  for auto arg <- args if auto rest = arg.startsWith "-lightrot=" lightrot = std.string.atof rest;
  int threads = 6; // number of subdivisions
  for auto arg <- args if auto rest = arg.startsWith "-threads=" threads = rest.atoi();
  int samples = 1;
  for auto arg <- args if auto rest = arg.startsWith "-samples=" samples = rest.atoi();
  (int, int) imgres; // fixed-size single-pass render
  for auto arg <- args if auto rest = arg.startsWith "-res=" using rest.split("x") imgres = (that[0].atoi(), that[1].atoi());
  string file = "out.png";
  for auto arg <- args if auto rest = arg.startsWith "-o=" file = rest;
  bool jitter;
  for auto arg <- args if arg == "-jitter" jitter = true;
  for auto arg <- args if arg == "-keep-going" break-on-float-errors = false;

  if (break-on-float-errors)
    for auto val <- [FE_DIVBYZERO, FE_INVALID/*, FE_OVERFLOW I said infs are fine >_>*/]
      feenableexcept val;
  
  // scene = new LightSource(&lightpos, scene);
  float ratio = 1;
  if (imgres[0]) ratio = imgres[0] * 1f / imgres[1];
  
  (int, int) desired-display-size;
  if (imgres[0] && imgres[1]) desired-display-size = imgres;
  
  vec2f getScale() {
    return 2.0f * vec2f(ratio, 1) / vec2f(desired-display-size);
  }
  if (jitter) {
    scene = new AverageResults(samples, new JitterRay(&getScale, new PathTraceLighting(scene, new PathTraceLighting (scene, new PathTraceLighting scene))));
  } else {
    scene = new PathTraceLighting(samples, scene, new PathTraceLighting (scene, new PathTraceLighting scene));
  }
  
  vec4f[] resbuffer;
  
  VMStats stats;
  stats.rays-needed-cur = 1;
  stats.results-needed-cur = 0;
  auto stream = scene.buildCommandStream(&stats);
  stream ~= CommandHandler: null; // terminator
  int rays-needed = stats.rays-needed-max;
  int results-needed = stats.results-needed-max;
  writeln "($rays-needed, $results-needed): $(stream[0..$-1])";
  writeln "steps: $(stream.length - 1)";
  
  auto start = sec(), firststart = start;
  int iters; long rays;
  
  alias tilesize = 10;
  
  auto ray-res-vm-map = new (Ray[], Result[], VMState[])[] threads;
  void* align16(void* v) { return void*:(int:v + 15 #&-16); }
  void render(int thread, int tile) {
    lightpos = vec3f(sin(lightrot) * 10 - 5, 5, cos(lightrot) * 10);
    (int dw, int dh) = desired-display-size;
    alias my-ray-map = ray-res-vm-map[thread][0];
    alias my-res-map = ray-res-vm-map[thread][1];
    alias my-vm-map = ray-res-vm-map[thread][2];
    int count = tilesize * tilesize;
    // split into subfunctions for the benefit of the profiler.
    void setup() {
      auto xstream = stream;
      int resn = results-needed, rayn = rays-needed;
      // prealloc vm, results, rays
      if (my-vm-map.length != count + 1) {
        my-vm-map.free;
        my-vm-map = new VMState[] (count + 1);
      }
      if (my-ray-map.length != count * rayn + 1) {
        my-ray-map.free;
        my-ray-map = new Ray[] (count*rayn + 1);
      }
      if (my-res-map.length != count * resn + 1) {
        my-res-map.free;
        my-res-map = new Result[] (count*resn + 1);
      }
      Ray[] ray-slab = Ray*:align16(my-ray-map.ptr) #[0..my-ray-map.length - 1];
      Result[] res-slab = Result*:align16(my-res-map.ptr) #[0..my-res-map.length - 1];
      auto state = VMState*:align16(my-vm-map.ptr);
      
      int xfrom = tile % (dw / tilesize) # * tilesize;
      int yfrom = tile / (dw / tilesize) # * tilesize;
      int xto = xfrom + tilesize, yto = yfrom + tilesize;
      
      for (int y, int x) <- cross(yfrom..yto, xfrom..xto) {
        // float fx = x / (dw/2f) - 1f, fy = 1f - y / (dh/2f);
        using state {
          // result-id = 0;
          // ray-id = 1;
          result-stack = res-slab.ptr; res-slab = res-slab[resn .. $];
             ray-stack = ray-slab.ptr; ray-slab = ray-slab[rayn .. $];
          for auto i <- 0..resn
            result-stack[i].emissive-color = vec3f(0);
          // auto dir = vec3f(fx, fy, 1);
          // dir /= vec3f(|dir|);
          // ray.pos = vec3f(0, 2, 0);
          // ray.dir = dir;
          stream = xstream;
        }
        state.(x, y) = (x, y);
        state ++;
      }
      fastsetup(xfrom, xto, yfrom, yto, dw, dh, align16(&my-vm-map[0]));
    }
    void process() {
      check;
      auto rayqueue = VMState*:align16(my-vm-map.ptr) #[0..my-vm-map.length - 1];
      // writeln "PROCESS";
      do {
        while (rayqueue.length && !rayqueue[0].handler) rayqueue = rayqueue[1 .. $];
      } while (rayqueue.length) {
        auto hdl = rayqueue[0].stream.ptr;
        for auto rq <- rayqueue if int:rq.stream.ptr < int:hdl hdl = rq.stream.ptr;
        // int num;
        // for auto rq <- rayqueue if int:rq.handler == int:*hdl num++;
        // writeln "$(*hdl): $num out of $(rayqueue.length)";
        hdl.process rayqueue;
      }
      // writeln "END";
    }
    void finalize() {
      auto state = VMState*:align16(my-vm-map.ptr);
      for int i <- 0 .. count {
        auto res = &state.result-stack[0];
        int tile = (state.y / tilesize) * (dw / tilesize) + (state.x / tilesize);
        auto rp = &resbuffer[(tile * tilesize + state.y % tilesize) * tilesize + (state.x % tilesize)];
        if (!res.success) *rp = vec4f.W;
        else {
          *rp = res.emissive-color;
          float maxf(float a, b) return [a, b][eval b > a];
          if (rp.(maxf(x, maxf(y, z))) > 1)
            (*rp) /= rp.(maxf(x, maxf(y, z)));
          rp.w = 1;
        }
        state ++;
      }
    }
    setup();
    process();
    finalize();
  }
  
  auto lp = new LoopPool threads;
  
  if (imgres[0] && imgres[1]) {
    
    resbuffer = new vec4f[] (imgres[0] * imgres[1]);
    resbuffer[] = [for 0..resbuffer.length: vec4f.W];
    
    auto surf = screen(imgres, surface => true);
    writeln "Calculate $(imgres). ";
    bool done; int tiles-done;
    void save() {
      auto gdp = gdImageCreateTrueColor(imgres);
      onSuccess gdImageDestroy gdp;
      // MORE COPYPASTE (from below)
      int xtiles = surf.w / tilesize, ytiles = surf.h / tilesize;
      int tiles = xtiles * ytiles;
      int k;
      for int tile <- 0..tiles {
        int xfrom = tile % xtiles # * tilesize;
        int yfrom = tile / xtiles # * tilesize;
        int xto = xfrom + tilesize, yto = yfrom + tilesize;
        for (int y, int x) <- cross(yfrom .. yto, xfrom .. xto) {
          gdp.tpixels[y][imgres[0] - 1 - x] = floatToIntColor resbuffer[k++].(xyz/w);
        }
      }
      auto hdl = fopen (file.toStringz(), "w");
      gdImagePng(gdp, c.gd.FILE*: hdl);
      fclose hdl;
    }
    new ThreadPool 1 #.addTask delegate void() {
      auto start = sec();
      while !done {
        auto t = sec(), delta = float:(t - start);
        if (tiles-done) {
          int num-tiles = (imgres[0] * imgres[1]) / (tilesize * tilesize);
          writeln "$(int:delta)s: $(tiles-done * 100 / num-tiles)% done, est. $(int:(delta * num-tiles / tiles-done - delta))s left. ";
        }
        save();
        sleep 1;
      }
    };
    lp.runLoop((imgres[0] / tilesize) * (imgres[1] / tilesize), delegate void(int tile-id, thr) { render(thr, tile-id); tiles-done ++; });
    done = true;
    writeln "Save. ";
    save();
    return;
  }
  
  auto resbuffer-lock = new ReadWriteLock;
  
  auto surf = screen(600, 600, surface => true);
  desired-display-size = surf.(w, h);
  
  resbuffer = new vec4f[] surf.(w * h);
  resbuffer[] = [for 0..resbuffer.length: vec4f.W];
  
  onResize(800, 800);
  bool stop;
  using new ThreadPool 1::
  addTask delegate void() {
    auto last-printed = sec();
    while !stop {
      resbuffer-lock.lock-read();
        auto rdg = &render;
        auto ddsx = desired-display-size[0], ddsy = desired-display-size[1], tilesize = tilesize;
        lp.runLoop((ddsx * ddsy) / (tilesize * tilesize), delegate void(int tile, thr) { rdg(thr, tile); });
      resbuffer-lock.unlock();
      iters ++;
      rays += surf.(w*h);
      // render();
      // lightrot += 0.1;
      auto delta = float:(sec() - start);
      auto fulldelta = float:(sec() - firststart);
      float fps;
      if (delta > 0) fps = iters / delta;
      else fps = 0.001; // eps
      // reconfigure window size to reach target fps
      float pixelfactor = desired-fps / fps, psq = sqrtf pixelfactor;
      float absf(float f) { if (f < 0) return -f; return f; }
      if (float:(sec() - last-printed) > 5) {
        writeln "[fps $fps] [wanted $desired-fps] [res $desired-display-size] [speed $(surf.(w*h) * iters / delta / 1_000_000)mrps] [full speed $(double:rays / fulldelta / 1_000_000)mrps]";
        last-printed = sec();
      }
      if (absf (pixelfactor - 1) > 0.05 && delta > 1) {
        if (psq < 0.7) psq = 0.7;
        (int, int) updated-size = (int:(surf.w / psq), int:(surf.h / psq));
        updated-size = (updated-size[0] / 10 #* 10, updated-size[1] / 10 #* 10);
        resbuffer-lock.lock-write();
          desired-display-size = updated-size;
          resbuffer.free;
          resbuffer = new vec4f[] (updated-size[0] * updated-size[1]);
          resbuffer[] = [for 0..resbuffer.length: vec4f.W];
        resbuffer-lock.unlock();
        // reset estimation
        iters = 0; start = sec();
      }
    }
  };
  set-handler(Error err) {
    writeln "$err. Exiting. ";
    invoke-exit "main-return";
  }
  define-exit "main-return" {
    stop = true;
    waitComplete;
    return;
  }
  auto begin = sec();
  int tex;
  glGenTextures(1, &tex);
  onSuccess glDeleteTextures(1, &tex);
  while (true) {
    auto start-draw = sec();
    resbuffer-lock.lock-read();
    int xtiles = surf.w / tilesize, ytiles = surf.h / tilesize;
    int tiles = xtiles * ytiles;
    int k;
    for int tile <- 0..tiles {
      // ahh .. the sweet sound of copypaste
      int xfrom = tile % xtiles # * tilesize;
      int yfrom = tile / xtiles # * tilesize;
      int xto = xfrom + tilesize, yto = yfrom + tilesize;
      for (int y, int x) <- cross(yfrom .. yto, xfrom .. xto) {
        surf.pset(x, y, resbuffer[k++].(xyz/w));
      }
    }
    resbuffer-lock.unlock();
    mode GL {
      Viewport (0, 0, display.(w, h));
      MatrixMode PROJECTION;
      LoadIdentity;
      MatrixMode MODELVIEW;
      LoadIdentity;
      using TEXTURE_2D {
        Enable;
        BindTexture tex;
        TexParameteri(TEXTURE_MIN_FILTER, NEAREST);
        TexParameteri(TEXTURE_MAG_FILTER, NEAREST);
        TexImage2D (0, 3, surf.(w, h), 0, 0x80E1 /*BGRA*/, UNSIGNED_BYTE, surf.surf.back.pixels);
      }
      ClearColor (1, 1, 0, 0);
      Clear (COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
      
      using Quads {
        Vertex2f( 1, -1); TexCoord2f(0, 0);
        Vertex2f( 1,  1); TexCoord2f(1, 0);
        Vertex2f(-1,  1); TexCoord2f(1, 1);
        Vertex2f(-1, -1); TexCoord2f(0, 1);
      }
    }
    surf.surf.flip;
    SDL_GL_SwapBuffers();
    flip;
    auto end-draw = sec();
    auto should-take = 1f / desired-fps, delta = should-take-end-draw+start-draw /* abusive */;
    if (should-take > 0)
      sleep should-take;
    if (surf.(w != desired-display-size[0] || h != desired-display-size[1])) {
      surf = screen (desired-display-size, surface => true);
    }
  }
}
