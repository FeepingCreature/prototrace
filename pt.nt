module pt;

import sdl, opengl, std.math, std.thread, std.boehm, std.file, std.string;

import
  scene.checkerpattern, scene.group, scene.plane, scene.scale,
  scene.sphere, scene.translate, scene.triangle, scene.base;

extern(C) {
  void fastsetup(int yfrom, yto, dw, dh, VMState*);
  void fast_light_process(VMState*, int numstates, vec3f* lightpos, void* self);
}

class LightStep : CommandHandler {
  vec3f* lightpos;
  void init(vec3f* lp) { lightpos = lp; }
  void process(VMState[] list) {
    fast_light_process(list.ptr, list.length, lightpos, void*:CommandHandler:this);
    return;
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto res = sp.result;
      if (res.success) {
        auto nspos = sp.ray.(pos + dir * (res.distance * 0.999));
        // writeln "nspos = $(ray.(pos, dir)) @ $(res.distance) = $(nspos)";
        using sp mixin(allocRay);
        vec3f lightdir = ((*lightpos) - nspos).normalized;
        sp.ray.(pos, dir) = (nspos, lightdir);
      } else {
        sp.stream = sp.stream[$-1 .. $]; // no point
      }
    }
  }
}

import std.time;
import c.fenv;
extern(C) { void GC_disable(); void GC_gcollect(); void GC_enable(); }
extern(C) int feenableexcept(int);
void main() {
  void check() {
    if (!(mxcsr & (1 << 15))) {
      writeln "Oops! FTZ has gotten 0. Resetting. $(mxcsr)";
      // _interrupt 3;
      mxcsr |= (3 << 13) | (1 << 15);
      for auto val <- [FE_DIVBYZERO, FE_INVALID, FE_OVERFLOW]
        feenableexcept val;
    }
  }
  for auto val <- [FE_DIVBYZERO, FE_INVALID, FE_OVERFLOW]
    feenableexcept val;
  initBoehm debugMode => true;
  auto surf = screen(150, 150, surface => true);
  
  onResize = delegate void(int w, int h) {
    screen(w, h, flags => SDL_OPENGL | SDL_RESIZABLE);
  };
  onResize(800, 800);
  
  SceneObject scene;
  SceneObject teapot;
  using new TriangleSet {
    auto obj = string: readAll "teapot.obj" #.split "\n";
    string[] selectAs(string delegate(string) dg) {
      string[auto~] res;
      for auto line <- obj if auto thing = dg line res ~= thing;
      return res[];
    }
    auto vertices = [for array <- [for v <- selectAs(delegate string(string s) return s.startsWith "v ";): [for part <- v.split " ": std.string.atof part].eval[]]: vec3f(array[(0, 1, 2)])].eval[];
    auto polys = [for v <- selectAs(delegate string(string s) return s.startsWith "f ";): v.split " "];
    for auto poly <- polys if (poly.length == 4) {
      auto indices = [for id <- [for part <- poly: part.split "/" #[0]]: vertices[std.string.atoi id - 1]].eval[];
      addTriangle indices[(0, 1, 2)];
      addTriangle indices[(0, 2, 3)];
    }
    // writeln "$(infos.length) tris. ";
    writeln "aabb = $(that.aabb.a), $(that.aabb.b)";
    optimize;
    writeln "Tree optimized";
    teapot = that;
  }
  using new Group {
    // list ~= new CheckerPattern(vec3f(0, 1, 0), vec3f(0, 0, 1), new Plane(vec3f(0, 1, 0), vec3f(0, 0, 0)));
    // list ~= new Translate(vec3f(0, 0, 5), new Scale(0.2, new CheckerPattern(vec3f(0, 1, 0), vec3f(1, 0, 0), new Sphere(vec3f(0, 0, 0), 10))));
    // list ~= new Translate(vec3f(0, 0, 5), new Scale(2.5, new Triangle(vec3f(-1, 0.1, -1), vec3f(-1, 0.1, 1), vec3f(1, 0.1, -1))));
    list ~= new Translate(vec3f(0, 0, 5), new Scale(1/30.0, teapot));
    scene = that;
  }
  
  vec3f lightpos;
  
  VMStats stats;
  auto stream = scene.buildCommandStream(&stats);
  stream = stream ~ new LightStep(&lightpos) ~ stream;
  stream ~= CommandHandler: null; // terminator
  int rays-needed = stats.rays-needed-max * 2 + 1;
  int results-needed = stats.results-needed-max * 2;
  writeln "($rays-needed, $results-needed): $(stream[0..$-1])";
  
  vec3f[] resbuffer = new vec3f[] (surf.w * surf.h);
  float desired-fps = 1;
  float lightrot = 0;
  alias threads = 6; // number of subdivisions
  auto start = sec();
  int iters;
  (int, int) desired-display-size = surf.(w, h);
  
  auto vm-map = new VMState[][] threads;
  void render(int thread, int yfrom, yto) {
    lightpos = vec3f(sin(lightrot) * 10 - 5, 5, cos(lightrot) * 10);
    (int dw, int dh) = desired-display-size;
    alias my-map = vm-map[thread];
    int desired-length = (yto - yfrom) * dw;
    if (my-map.length != desired-length) {
      my-map = new VMState[] desired-length;
    }
    // split into subfunctions for the benefit of the profiler.
    void setup() {
      auto state = &my-map[0];
      auto xstream = stream;
      int resn = results-needed, rayn = rays-needed;
      // prealloc results and rays
      int count = (yto - yfrom) * dw;
      Ray[] ray-slab;
      Result[] res-slab;
      for (int y, int x) <- cross(yfrom..yto, 0..dw) {
        // float fx = x / (dw/2f) - 1f, fy = 1f - y / (dh/2f);
        using state {
          // result-id = 0;
          // ray-id = 1;
          if (result-stack.length != resn) {
            if (!res-slab.length) res-slab = new Result[] (count * resn);
            (result-stack, res-slab) = res-slab[(0 .. resn, resn .. $)];
          }
          if (ray-stack.length != rayn) {
            if (!ray-slab.length) ray-slab = new Ray[] (count * rayn);
            (ray-stack, ray-slab) = ray-slab[(0 .. rayn, rayn .. $)];
          }
          // auto dir = vec3f(fx, fy, 1);
          // dir /= vec3f(|dir|);
          // ray.pos = vec3f(0, 2, 0);
          // ray.dir = dir;
          stream = xstream;
        }
        state ++;
      }
      fastsetup(yfrom, yto, dw, dh, &my-map[0]);
    }
    void process() {
      check;
      auto rayqueue = my-map;
      do {
        while (rayqueue.length && !rayqueue[0].handler) rayqueue = rayqueue[1 .. $];
      } while (rayqueue.length) {
        auto hdl = rayqueue[0].handler;
        hdl.process rayqueue;
      }
    }
    void finalize() {
      auto my-resbuffer = resbuffer[yfrom * dw .. yto * dw];
      auto state = &my-map[0];
      auto resptr = my-resbuffer.ptr;
      for int i  <- 0 .. my-map.length {
        auto res = &state.result-stack[0];
        if (!res.success) *resptr = vec3f(0);
        else {
          // TODO: vec3f(x) should always lvize x!
          auto res2 = &state.result-stack[1];
          auto ray = &state.ray-stack[0];
          float scaled-dist = res.distance * 0.99;
          vec3f lightdir = lightpos - (ray.pos + ray.dir * vec3f(scaled-dist));
          float lightdist = |lightdir|;
          lightdir = lightdir.normalized;
          // lightdir = lightdir / vec3f(lightdist);
          vec3f lightprod = lightdir * res.normal;
          float lightangle = lightprod.sum;
          *resptr = vec3f(0);
          if (lightangle >= 0 && (!res2.success || res2.distance >= lightdist)) {
            *resptr = res.col * vec3f(lightangle);
          }
        }
        state ++;
        resptr ++;
      }
    }
    setup();
    process();
    finalize();
  }
  
  auto lp = new LoopPool threads;
  auto resbuffer-lock = new ReadWriteLock;
  
  bool stop;
  using new ThreadPool 1::
  addTask delegate void() {
    auto last-printed = sec();
    while !stop {
      resbuffer-lock.lock-read();
        auto rdg = &render;
        auto ddsy = desired-display-size[1];
        lp.runLoop(ddsy, delegate void(int line, int thr) { rdg(thr, line, line + 1); });
      resbuffer-lock.unlock();
      iters ++;
      // render();
      lightrot += 0.1;
      auto delta = float:(sec() - start);
      float fps;
      if (delta > 0) fps = iters / delta;
      else fps = 0.001; // eps
      // reconfigure window size to reach target fps
      float pixelfactor = desired-fps / fps, psq = sqrtf pixelfactor;
      float absf(float f) { if (f < 0) return -f; return f; }
      if (float:(sec() - last-printed) > 5) {
        writeln "[fps $fps] [wanted $desired-fps] [res $desired-display-size] [speed $(surf.(w*h) * iters / delta / 1_000_000)mrps]";
        last-printed = sec();
      }
      if (absf (pixelfactor - 1) > 0.05 && delta > 1) {
        if (psq < 0.7) psq = 0.7;
        (int, int) updated-size = (int:(surf.w / psq), int:(surf.h / psq));
        resbuffer-lock.lock-write();
          desired-display-size = updated-size;
          resbuffer.free;
          resbuffer = new vec3f[] (updated-size[0] * updated-size[1]);
        resbuffer-lock.unlock();
        // reset estimation
        iters = 0; start = sec();
      }
    }
  };
  set-handler(Error err) {
    writeln "$err. Exiting. ";
    invoke-exit "main-return";
  }
  define-exit "main-return" {
    stop = true;
    waitComplete;
    return;
  }
  auto begin = sec();
  while (true) {
    auto start-draw = sec();
    resbuffer-lock.lock-read();
      for (int y, int x) <- cross(0..surf.h, 0..surf.w) {
        surf.pset(x, y, resbuffer[y * desired-display-size[0] + x]);
      }
    resbuffer-lock.unlock();
    surf.surf.flip;
    mode GL {
      Viewport (0, 0, display.(w, h));
      int tex;
      GenTextures(1, &tex);
      MatrixMode PROJECTION;
      LoadIdentity;
      MatrixMode MODELVIEW;
      LoadIdentity;
      using TEXTURE_2D {
        Enable;
        BindTexture tex;
        TexParameteri(GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        TexImage2D (0, 3, surf.(w, h), 0, GL_BGRA, GL_UNSIGNED_BYTE, surf.surf.back.pixels);
      }
      ClearColor (1, 0, 0, 0);
      Clear (COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
      
      using Quads {
        Vertex2f( 1, -1); TexCoord2f(0, 0);
        Vertex2f( 1,  1); TexCoord2f(1, 0);
        Vertex2f(-1,  1); TexCoord2f(1, 1);
        Vertex2f(-1, -1); TexCoord2f(0, 1);
      }
      Flush;
      DeleteTextures(1, &tex);
    }
    SDL_GL_SwapBuffers();
    flip;
    auto end-draw = sec();
    auto should-take = 1f / desired-fps, delta = should-take-end-draw+start-draw /* abusive */;
    if (should-take > 0)
      sleep should-take;
    if (surf.(w != desired-display-size[0] || h != desired-display-size[1])) {
      surf = screen (desired-display-size, surface => true);
    }
  }
}
