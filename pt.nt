module pt;

shared int c__, c__2, c__3;
import opengl, std.math, sdl, std.thread, std.file, std.string;
import std.boehm;
import std.macros.swap;

import
  scene.checkerpattern, scene.group, scene.plane, scene.scale,
  scene.sphere, scene.translate, scene.triangle, scene.util,
  scene.color, scene.base, scene.bound, scene.envmap, scene.texture;

pragma(linker, "fastroutines.o");

alias EPS = 0.999;
alias groupsize = 1024;

extern(C) {
  void fastsetup(Ray** rayplanes, int from, to, dw, dh, stepsize, VMState*);
  void fast_light_process(Ray**, Result**, VMState*, int numstates, vec3f* lightpos, void* self);
  void coordsf_to_ray(int dw, dh, float x, y, Ray* rayp);
  void coords_to_ray(int dw, dh, int x, y, Ray* rayp);
  void ray_to_coords(int dw, dh, Ray* rayp, int* xp, yp);
  void ray_to_coordsf(int dw, dh, Ray* rayp, float* xp, yp);
  float fov;
}

int dw, dh;

int markovSteps, burnInLimit;
float minBrightnessFactor;
(int, int) dbgPos;


import gd;
Texture* readImage(string fname) {
  if (!fname.exists()) {
    if      exists auto asPNG = "$fname.png" fname = asPNG;
    else if exists auto asJPG = "$fname.jpg" fname = asJPG;
    else if exists auto asHDR = "$fname.hdr" fname = asHDR;
    else raise new Error "No such image: $fname";
  }
  auto res = new Texture;
  auto fdata = readAll fname;
  if (fname.toLower().endsWith ".jpg") { res.gdp = gdImageCreateFromJpegPtr(fdata.(length, ptr)); return res; }
  if (fname.toLower().endsWith ".png") { res.gdp = gdImageCreateFromPngPtr(fdata.(length, ptr)); return res; }
  if (fname.toLower().endsWith ".hdr") { res.hdp = parseHDR(fdata, fname); return res; }
  raise new Error "Unknown extension in '$fname'! ";
}

class LightStep : CommandHandler {
  vec3f* lightpos;
  int numBasicSteps;
  void init(vec3f* lp, int n) { lightpos = lp; numBasicSteps = n; }
  class LightMergeStep : CommandHandler {
    void process(VMState[] list) {
      for int i <- 0 .. list.length {
        auto sp = &list[i];
        
        if (void*:sp.handler == void*:CommandHandler:this)::
        sp.stream = sp.stream[1..$];
        
        auto res = &resplanes[sp.result-id-2][i];
        if (res.success) {
          auto ray1 = &rayplanes[sp.ray-id-1][i];
          auto ray2 = &rayplanes[sp.ray-id-2][i];
          vec3f lightdir = (*lightpos) - ray1.pos;
          float lightdist = |lightdir|;
          lightdir = lightdir.normalized;
          auto norm = res.normal;
          if ((norm * ray2.dir).sum > 0)
            norm = -norm;
          vec3f lightprod = lightdir * norm;
          float lightangle = lightprod.sum;
          
          vec3f resv = vec3f(0);
          auto res2 = &resplanes[sp.result-id-1][i];
          if (lightangle >= 0 && (!res2.success || res2.distance >= lightdist))
            resv = res.reflective-color * vec3f(lightangle);
          
          res.emissive-color += resv;
        }
        using sp mixin(freeResult.replace("!!", "1"));
        using sp mixin(freeRay.replace("!!", "1"));
      }
    }
  }
  LightMergeStep mkMergeStep() { return new LightMergeStep; }
  void process(VMState[] list) {
    // TODO: rewrite
    // fast_light_process(rayplanes.ptr, resplanes.ptr, list.ptr, list.length, lightpos, void*:CommandHandler:this);
    // return;
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto res = &resplanes[sp.result-id-1][i];
      if (res.success) {
        auto ray = &rayplanes[sp.ray-id-1][i];
        auto nspos = ray.(pos + dir * (res.distance * EPS));
        // writeln "nspos = $(sp.ray.(pos, dir)) @ $(res.distance) = $(nspos), lightpos $(*lightpos)";
        using sp mixin(allocRay);
        vec3f lightdir = ((*lightpos) - nspos).normalized;
        ray = &rayplanes[sp.ray-id-1][i];
        ray.(pos, dir) = (nspos, lightdir);
      } else {
        using sp mixin(allocRay);
        using sp mixin(allocResult);
        sp.stream = sp.stream[numBasicSteps .. $]; // skip
      }
    }
  }
}

import std.random;
IRandom rng;
float randf() { return std.random.base.randf(rng); }
float Crandf(void* p) { auto backup = _esi; _esi = p; float res = std.random.base.randf(rng); _esi = backup; return res; }
int rand() { return rng.rand(); }
void init() {
  rng = getPRNG(23);
  auto dg = onThreadCreation;
  onThreadCreation = new delegate void(void* basep) {
    if (dg) { dg(basep); }
    rng = getPRNG(int:basep);
  };
}

vec3f rand_sphere() {
  vec3f res;
  // TODO: undo
  do res = vec3f((randf() * 2 - 1) x 3);
  while |res| > 1 { }
  return res.normalized;
}

(float, float) vary(float x, y, int spread) {
  float randf2() {
    alias shift = -2;
    float f = (randf() - 0.5) * 2 * spread;
    if (f < 0) return -pow(2, -f + shift);
    else       return  pow(2, f + shift);
  }
  return (x+randf2(), y+randf2());
}

vec2f delegate() getScale;

class RandomizeRay : CommandHandler {
  int src;
  void init(int src = -1) { this.src = src; }
  void process(VMState[] list) {
    auto sc = getScale();
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      Ray* ray;
      if (src == -1) ray = &rayplanes[sp.ray-id-1][i];
      else ray = &rayplanes[src][i];
      
      using sp mixin(allocRay.replace("!!", "1"));
      
      auto nray = &rayplanes[sp.ray-id-1][i];
      
      float fx, fy;
      ray_to_coordsf(dw, dh, ray, &fx, &fy);
      // (fx, fy) = vary(fx, fy, 5);
      // fx += randf() - 0.5;
      // fy += randf() - 0.5;
      fx = randf() * dw;
      fy = randf() * dh;
      coordsf_to_ray(dw, dh, fx, fy, nray);
    }
  }
}

void generateOutRay(Ray* ray, Ray* prev-ray, vec3f start, Result* resinfo) {
  ray.(pos, dir) = (start, rand_sphere());
  auto normal = resinfo.normal;
  // flip the normal if we approached the surface from the "backside"
  // this accounts for things like triangle models where a triangle may be visible from both sides
  // on an unrelated note, fuck those bullshit models
  if ((normal * prev-ray.dir).sum >= 0)
    normal = -normal;
  
  if (ray.dir * normal).sum < 0 ray.dir = -ray.dir;
}

class PathTraceStep : CommandHandler {
  int skip, res-delta;
  void init(int s, int rd = 0) { skip = s; res-delta = rd; } 
  class PathTraceMergeStep : CommandHandler {
    void process(VMState[] list) {
      for int i <- 0 .. list.length {
        auto sp = &list[i];
        
        if (void*:sp.handler == void*:CommandHandler:this)::
        sp.stream = sp.stream[1..$];
        
        auto res = &resplanes[sp.result-id-2][i];
        if (res.success) {
          auto res2 = &resplanes[sp.result-id-1][i];
          if (res2.success) {
            res.emissive-color += res.reflective-color * res2.emissive-color;
          }
        }
        using sp mixin(freeResult.replace("!!", "1"));
      }
    }
  }
  auto mkMergeStep() { return new PathTraceMergeStep; }
  void process(VMState[] list) {
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(allocRay);
      
      auto res = &resplanes[sp.result-id-1 - res-delta][i];
      if (res.success && res.reflective-color != vec3f(0)) {
        auto ray = &rayplanes[sp.ray-id-2][i];
        auto ray2 = &rayplanes[sp.ray-id-1][i];
        auto nspos = ray.(pos + dir * (res.distance * EPS));
        // writeln "nspos = $(ray.(pos, dir)) @ $(res.distance) = $(nspos)";
        generateOutRay(ray2, ray, nspos, res);
      } else {
        using sp mixin(allocResult);
        sp.stream = sp.stream[skip .. $]; // no point
      }
    }
  }
}

alias atoi = std.string.atoi;
alias atof = std.string.atof;

class LightSource : SceneObject {
  SceneObject sup;
  vec3f* ls;
  void init(vec3f* ls, SceneObject sup) this.(ls, sup) = (ls, sup);
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.needsResult;
    stats.needsRay;
    auto stream = sup.buildCommandStream(stats);
    stats.results-needed-cur --;
    stats.rays-needed-cur --;
    using new LightStep(ls, stream.length)
      return stream ~ that ~ stream ~ mkMergeStep();
  }
}

class PathTraceLighting : SceneObject {
  SceneObject sup, sup2; int avg;
  void init(SceneObject sup) this.(sup, sup2, avg) = (sup, sup, 1);
  void init(SceneObject sup, sup2) this.(sup, sup2, avg) = (sup, sup2, 1);
  void init(int avg, SceneObject sup) this.(sup, sup2, avg) = (sup, sup, avg);
  void init(int avg, SceneObject sup, sup2) this.(sup, sup2, avg) = (sup, sup2, avg);
  CommandHandler[] buildCommandStream(VMStats* stats) {
    auto stream = sup.buildCommandStream(stats);
    
    CommandHandler[auto~] res;
    res ~= stream; // results ++
    if (avg == 1) {
      stats.needsRay;
      auto stream2 = sup2.buildCommandStream(stats);
      stats.rays-needed-cur --;
      using new PathTraceStep(stream.length) {
        res ~= that; // rays ++
        res ~= stream2; // results ++
        res ~= new FreeRay; // rays --
        res ~= mkMergeStep(); // results --;
      }
      // summary: neutral
    } else {
      int base-id = stats.results-needed-cur;
      stats.needsRay;
      stats.needsResult;
      auto stream2 = sup2.buildCommandStream(stats);
      stats.results-needed-cur --;
      stats.rays-needed-cur --;
      auto pt = new PathTraceStep(stream.length, 1 /* skip one result (our empty averager) */);
      auto fr = new FreeRay;
      auto as = new AverageStep (avg, base-id, base-id + 1);
      auto fs = new FreeResult;
      res ~= new AllocEmptyResult; // results ++
      for (int i = 0; i < avg; ++i) {
        res ~= pt; // rays ++
        res ~= stream2; // results ++
        res ~= fr; // rays --
        res ~= as;
        res ~= fs; // results --
      }
      res ~= pt.mkMergeStep(); // results --
      // neutral
    }
    return res[];
  }
}

float value(vec3f v, bool isBack) {
  alias r = v.x, g = v.y, b = v.z;
  auto res = r * 0.2 + g * 0.3 + b * 0.5;
  if (isBack && res > 0.05) res = 0.05; // sanity limit for background
  // if (isBack) res /= 10K;
  return res;
}

void delegate(Ray* rayp, vec3f col, bool isBack, float factor, bool isMetroHit) recordResultDg;

void recordState(VMState* sp, int i, int skipRays, skipResults, vec3f v, bool isBack, float bias) {
  bool record;
  bool isMetroHit = true;
  if (sp.burnInCounter > 0) sp.burnInCounter --;
  else record = true;
  if (record) { c__2 ++; recordResultDg (&rayplanes[skipRays][i], v, isBack, bias, isMetroHit => isMetroHit); }
}

class RecordResultStep : CommandHandler {
  int skipRays, skipResults;
  void init(int skRay = 0, skRes = 0) (skipRays, skipResults) = (skRay, skRes);
  void process(VMState[] list) {
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto v = evaluateRay(sp, i, skipRays, skipResults, isBack => &bool b);
      recordState(sp, i, skipRays, skipResults, v, b, 1);
    }
  }
}

bool allowLensmut;

class MetropolisLighting : SceneObject {
  SceneObject sup; int samples, depth;
  void init(SceneObject sup) {
    this.(sup, depth, samples) = (sup, 3, 16);
  }
  void init(SceneObject sup, int dep, int samples) {
    this.(sup, depth, samples) = (sup, dep, samples);
  }
  class MetropolisStep : CommandHandler {
    int stepsToRewind;
    int firstRay, firstRes, skip;
    class Mutate1 : CommandHandler {
      int firstRay, firstRes, skip;
      void init(int firstId, firstResId, skipLen) (firstRay, firstRes, skip) = (firstId, firstResId, skipLen);
      void process(VMState[] list) {
        bool allowLensmut = allowLensmut;
        for int i <- 0 .. list.length {
          auto sp = &list[i];
          
          if (void*:sp.handler == void*:CommandHandler:this)::
          sp.stream = sp.stream[1..$];
          
          auto ray = &rayplanes[firstRay][i];
          auto res = &resplanes[firstRes][i];
          
          int whichCase;
          
          int caseId = rand() % 100;
          if (allowLensmut && caseId < 80) whichCase = 1; // lensmut
          else if (false && caseId < 90) whichCase = 2; // tailmut
          
          if (whichCase == 1) {
            sp.state = 0; // lens mutation
            ray_to_coordsf(dw, dh, ray, &float fx, &float fy);
            using sp mixin(allocRay);
            
            (fx, fy) = vary(fx, fy, 5);
            // while (fx < 0) fx += dw; while (fx >= dw) fx -= dw;
            // while (fy < 0) fy += dh; while (fy >= dh) fy -= dh;
            if (fx < 0) fx = 0; if (fx > dw - 1) fx = dw - 1;
            if (fy < 0) fy = 0; if (fy > dh - 1) fy = dh - 1;
            
            coordsf_to_ray(dw, dh, fx, fy, &rayplanes[sp.ray-id-1][i]);
            
            resplanes[firstRes][i].data = 0; // lens mutation in progress
          } else if (whichCase == 2) {
            sp.state = 1; // tail mutation
            // first, find the terminating ray .. walk until end reached
            int ray_offset;
            while (res.success && res.reflective-color != vec3f(0) && ray_offset < depth - 1) {
              ray_offset ++;
              res = &resplanes[firstRes + ray_offset][i];
              ray = &rayplanes[firstRay + ray_offset][i];
            }
            using sp mixin(allocRay);
            // "ray" now points at the last ray in the chain
            if (ray_offset) {
              res = &resplanes[firstRes + ray_offset - 1][i];
              ray = &rayplanes[firstRes + ray_offset - 1][i];
              generateOutRay(&rayplanes[sp.ray-id-1][i], ray, ray.pos, res);
              resplanes[firstRes][i].data = ray_offset + 1;
            } else {
              rayplanes[sp.ray-id-1][i] = rayplanes[firstRes][i]; // safe default
              sp.state = -1; // skip
            }
          } else {
            sp.state = 2; // new path mutation
          }
          // writeln "lens mutate $(*ray) to $(*sp.ray)";
        }
      }
    }
    
    class Mutate2 : CommandHandler {
      int firstRay, firstRes, skip;
      void init(int firstId, firstResId, skipLen) (firstRay, firstRes, skip) = (firstId, firstResId, skipLen);
      void process(VMState[] list) {
        for int i <- 0 .. list.length {
          auto sp = &list[i];
          
          if (void*:sp.handler == void*:CommandHandler:this)::
          sp.stream = sp.stream[1..$];
          
          // skip if tail mutating
          if (sp.state != 0 /* no second ray */) {
            using sp { mixin(allocRay); mixin(allocResult); }
            sp.stream = sp.stream[skip..$];
          } else::
          auto ray = &rayplanes[sp.ray-id-1][i], res = &resplanes[sp.result-id-1][i];
          auto oldray2 = &rayplanes[firstRay + 1][i];
          auto oldres2 = &resplanes[firstRes + 1][i];
          
          using sp mixin(allocRay);
          if (res.success && res.reflective-color != vec3f(0))::
          
          if (!oldres2.success) res.success = false;
          else::
          auto nuray = &rayplanes[sp.ray-id-1][i];
          nuray.pos = ray.(pos + dir * (res.distance * EPS));
          nuray.dir = oldray2.(pos + oldres2.distance * dir) - nuray.pos;
          if (nuray.dir.magnitude == 0) {
            writeln "problem for $(*oldray2) @$(oldres2.distance) compared to $$*nuray";
            nuray.dir = oldray2.dir; // hackaround
            // _interrupt 3;
          }
          nuray.dir = nuray.dir.normalized;
        }
      }
    }
    
    CommandHandler mkTestRaySelector(int baseRay, baseRes, skip) {
      return new Mutate1 (baseRay, baseRes, skip);
    }
    CommandHandler mkTestRaySelector2(int baseRay, baseRes, skip) {
      return new Mutate2 (baseRay, baseRes, skip);
    }
    void process(VMState[] list) {
      for int i <- 0 .. list.length {
        auto sp = &list[i];
        
        if (void*:sp.handler == void*:CommandHandler:this)::
        sp.stream = sp.stream[1..$];
        
        auto res = &resplanes[firstRes][i];
        // if this fails, the ray is over already
        int numFree = 2;
        if (sp.state == 2) numFree = depth;
        int depth = depth; // hax
        bool retry; /* same kind of mutation */
        void delegate() flipPath;
        int tailOffset; // kept outside the if so that the flipPath closure works
        if (res.success) {
          if (sp.state == -1) retry = true;
          else if (sp.state != 2) { // two-ray form
            auto data = res.data;
            if (data > 0) {
              // writeln "CASE1: $(data - 1) tail mutate";
              tailOffset = data - 1;
              auto res1 = &resplanes[sp.result-id-1][i];
              if (res1.reflective-color != vec3f(0)) {
                retry = true; // not part of the environment :(
              } else {
                flipPath = delegate void() {
                  swap rayplanes[firstRay + tailOffset][i], rayplanes[sp.ray-id-2][i];
                  swap resplanes[firstRes + tailOffset][i], resplanes[sp.result-id-2][i];
                  sp.cached = false;
                };
              }
            } else {
              // writeln "CASE2: lens mutate";
              auto res11 = &resplanes[firstRes][i];
              auto res12 = &resplanes[firstRes + 1][i];
              auto res21 = &resplanes[sp.result-id-2][i];
              auto res22 = &resplanes[sp.result-id-1][i];
              retry = true;
              
              // scenery mode!
              if (res11.success && res21.success && res11.reflective-color == vec3f(0) && res21.reflective-color == vec3f(0)) {
                retry = false;
                flipPath = \{
                  alias rp = rayplanes, ep = resplanes;
                  swap rp[firstRay][i], rp[sp.ray-id-2][i];
                  swap ep[firstRes][i], ep[sp.result-id-2][i];
                  sp.cached = false;
                };
              } else::
              float normaldot = res11.normal * res21.normal #.sum;
              // bool normalsDiffer = normaldot <= 0.99; // allow some drift with normals
              bool normalsDiffer = normaldot <= 0.8; // allow some drift with normals
              // float xnormaldot = 1 - (acosf (normaldot * 0.999)) / PI;
              bool newpathfail;
              if (normalsDiffer) newpathfail = true;
              if (res22.distance == 0) newpathfail = true;
              else {
                if (res21.normal * rayplanes[sp.ray-id-1][i].dir #.sum < 0) {
                  // second ray of lens mutation would have taken us into an object
                  newpathfail = true;
                }
              }
              if (!res11.success || !res21.success || res21.reflective-color == vec3f(0)
                || res12.distance == 0 || newpathfail)
              {
              } else::
              // scale by min distance traversed; smooth out rounding errors
              auto cpt1 = rayplanes[firstRay + 1][i].(pos + dir * res12.distance);
              auto cpt2 = rayplanes[sp.ray-id-1][i] .(pos + dir * res22.distance);
              auto delta = |cpt1 - cpt2|;
              delta /= [res12.distance, res22.distance][res22.distance < res12.distance];
              // connect the ray and rewind
              // writeln "collision pt 1{$(cpt1)} 2{$(cpt2)} delta $(delta) {* $([res1.distance, res3.distance][res3.distance < res1.distance])}";
              // writeln "ray1: $(sp.rays[firstRay])";
              // writeln "subst with $(sp.rays[$-2])";
              if (delta < 0.001) {
                retry = false;
                flipPath = \{
                  alias rp = rayplanes; alias ep = resplanes;
                  swap rp[firstRay  ][i], rp[sp.ray-id-2][i];
                  swap rp[firstRay+1][i], rp[sp.ray-id-1][i];
                  swap ep[firstRes  ][i], ep[sp.result-id-2][i];
                  swap ep[firstRes+1][i], ep[sp.result-id-1][i];
                  sp.cached = false;
                };
              }
            }
          } else {
            // writeln "set flipPath for case2: $depth";
            flipPath = delegate void() {
              auto start1 = sp.ray-id    - depth,
                   start2 = sp.result-id - depth;
              for int k <- 0..depth {
                swap rayplanes[firstRay+k][i], rayplanes[start1+k][i];
                swap resplanes[firstRes+k][i], resplanes[start2+k][i];
              }
              sp.cached = false;
            };
          }
          alias limit = markovSteps;
          if (sp.state2 < limit) {
            c__3++;
            sp.state2 ++;
            alias quad = (sp, i, firstRay, firstRes);
            if (retry) {
              // writeln "RETRY";
              // don't record result; instead, record present sample again
              // writeln "$failRecordBias";
              auto v = evaluateRay(quad, numFree, isBack => &bool b);
              recordState(quad, v, b, 1);
              sp.stream = sp.stream.ptr[-stepsToRewind + 1 .. sp.stream.length];
            } else {
              c__++;
              // metropolis happens here
              // writeln "firstRay $firstRay, firstRes $firstRes, sp.rays $(sp.rays.length), sp.results $(sp.results.length)";
              // metropolis light transport
              auto v1 = evaluateRay(quad, numFree, isBack => &bool isBackground1), f1 = value(v1, isBackground1);
              auto backup = sp.(rayCache, cached, cachedBack); // backup cache state
              flipPath();
              auto v2 = evaluateRay(quad, numFree, isBack => &bool isBackground2), f2 = value(v2, isBackground2);
              /*if (isBackground1 || isBackground2) {
                writeln "for $(isBackground1), $(isBackground2): $f1, $f2, $v1, $v2";
              }*/
              if (f2 >= f1) { // always switch to
                recordState(quad, v2, isBackground2, 1);
              } else if (f1 != 0) { // prevent div0 bug
                // probability of f2/f1
                float r = randf();
                float ratio = f2 / f1;
                // old ray is swapped to end
                recordState(sp, i, sp.ray-id - numFree, sp.result-id - numFree, v1, isBackground1, 1 - ratio);
                recordState(quad, v2, isBackground2, ratio);
                if (r < ratio) { // switch to
                } else { // stay
                  flipPath();
                  sp.(rayCache, cached, cachedBack) = backup; // restore cache state
                }
              } else {
                recordState(quad, v2, isBackground2, 1);
              }
              sp.stream = sp.stream.ptr[-stepsToRewind + 1 .. sp.stream.length];
              // standard path tracing
              /*flipPath();
              sp.stream = sp.stream.ptr[-stepsToRewind .. sp.stream.length];*/
            }
          }
        }
        using sp mixin(freeRay.replace("!!", "numFree"));
        using sp mixin(freeResult.replace("!!", "numFree"));
      }
    }
  }
  CommandHandler[] buildCommandStream(VMStats* stats) {
    CommandHandler[auto~] res;
    
    for (0..samples) {
      auto startinfo = stats.(rays-needed-cur, results-needed-cur);
      
      res ~= new CopyRay;
      stats.needsRay;
      
      int baseRay = stats.rays-needed-cur - 1; // ray is already created
      int baseRes = stats.results-needed-cur; // result will be created
      int baseSkip;
      alias baseTup = (baseRay, baseRes, baseSkip);
      CommandHandler[] buildPathTrace() {
        PathTraceStep lastPTStep;
        int i = 1;
        CommandHandler[auto~] res;
        do {
          auto stream = sup.buildCommandStream(stats);
          if (lastPTStep) lastPTStep.skip = stream.length;
          baseSkip = stream.length;
          res ~= stream;
        } while (i++ < depth) {
          using new PathTraceStep(0) {
            lastPTStep = that;
            res ~= that;
            stats.needsRay;
          }
        }
        return res[];
      }
      res ~= buildPathTrace();
      // ^
      // res += depth
      // rays += depth
      int rewindpos = res.length;
      res ~= new RecordResultStep(baseRay, baseRes);
      using new MetropolisStep {
        (firstRay, firstRes, skip) = baseTup;
        res ~= mkTestRaySelector baseTup; // doesn't add a ray if state == 2
        stats.needsRay;
        CommandHandler[] part1, part2;
        // if (state == 2) .. 
        // make use of rays-needed-cur++
        part1 ~= new RandomizeRay(baseRay/* - 1*/); // offer a new random path
        part1 ~= buildPathTrace();
        // reset
        stats.rays-needed-cur -= depth;
        stats.results-needed-cur -= depth;
        stats.needsRay; // restore
        // .. else ..
        part2 ~= sup.buildCommandStream(stats); // results ++
        part2 ~= mkTestRaySelector2 baseTup;
        stats.needsRay;
        part2 ~= sup.buildCommandStream(stats); // results ++
        // .. end if
        res ~= mkIfElse(2, part1, part2);
        // reset
        stats.rays-needed-cur -= 2;
        stats.results-needed-cur -= 2;
        
        res ~= that;
        
        stepsToRewind = res.length - rewindpos;
        
      }
      auto fr = new FreeRay, fs = new FreeResult;
      for 0..depth {
        res ~= fr;
        res ~= fs;
      }
      stats.rays-needed-cur -= depth;
      stats.results-needed-cur -= depth;
      assert(eval stats.(rays-needed-cur == startinfo[0] && results-needed-cur == startinfo[1]), "Ray/res allocation mismatch! ");
    }
    return res[];
  }
}

import std.getopt, std.time;
import c.fenv;
extern(C) { void GC_disable(); void GC_gcollect(); void GC_enable(); }
extern(C) int feenableexcept(int);
void main(string[] args) {
  set-handler (Error err) { writeln "$err. Aborting. "; asm `int $3`; }
  bool break-on-float-errors = true;

  float desired-fps = 0.5;
  int threads = 6; // number of subdivisions
  int samples = 1;
  (int, int) imgres; // fixed-size single-pass render
  string file = "out.png";
  int stepsize = 1;
  dbgPos = (-1, -1);
  markovSteps = 512;
  burnInLimit = 128;
  minBrightnessFactor = 0;
  useBoehm = true; // defined in scene.triangle
  allowLensmut = true;
  bool saveFrames;
  int depth = 3;
  float savestep = 4;
  bool average;
  using new Options {
    addLong("fps", "f", \(string s) desired-fps = std.string.atof s; );
    addLong("threads", "t", \(string s) threads = atoi s; );
    addLong("samples", "s", \(string s) samples = atoi s; );
    addLong("res", "r", \(string s) using s.split "x" imgres = (atoi that[0], atoi that[1]); );
    addLong("output", "o", \(string s) file = s; );
    addLong("keepgoing", "k", \ break-on-float-errors = false; );
    addLong("depth", "d", \(string s) depth = atoi s; );
    addLong("markovsteps", "m", \(string s) markovSteps = atoi s; );
    addLong("burninlimit", "l", \(string s) burnInLimit = atoi s; );
    addLong("minbrightnessfactor", "b", \(string s) minBrightnessFactor = atof s; );
    addLong("noboehm", "n", \ useBoehm = false; );
    addLong("noLensmut", "x", \ allowLensmut = false; );
    addLong("stepsize", "z", \(string s) stepsize = atoi s; );
    addLong("saveframes", "v", \ saveFrames = true; );
    addLong("stepsize", "e", \(string s) savestep = atof s; );
    addLong("average", "a", \() average = true; );
    addLong("help", "h", \{ printHelp; exit 0; });
    args = process args;
  }
  void check() {
    if (!(mxcsr & (1 << 15))) {
      writeln "Oops! FTZ has gotten 0. Resetting. $(mxcsr)";
      // _interrupt 3;
      // rtz, fz
      mxcsr |= (3 << 13) | (1 << 15);
      if (break-on-float-errors)
        for auto val <- [FE_DIVBYZERO, FE_INVALID/*, FE_OVERFLOW .. infs are fine*/]
          feenableexcept val;
    }
  }
  if (useBoehm)
    initBoehm (debugMode => true);
  
  onResize = delegate void(int w, int h) {
    screen(w, h, flags => SDL_OPENGL | SDL_RESIZABLE | SDL_ANYFORMAT);
  };
  
  SceneObject scene;
  SceneObject object;
  float lowest = 0;
  using new Group {
    auto bb = new BoxBound that;
    // alias objfile = "hikone.obj";
    alias objfile = "room box and sphere.obj";
    auto obj = string: import(objfile) #.split "\n";
    alias mtlfile = objfile.replace(".obj", ".mtl");
    auto mtl = string: import(mtlfile) #.split "\n";
    
    (string, Texture*)[auto~] matcache;
    Texture* lookupMatl(string matname) {
      for (string name, Texture* data) <- matcache if name == matname return data;
      bool inSection;
      auto firstmatch = "newmtl $matname";
      string fname;
      for auto line <- mtl {
        if (line.startsWith "newmtl ") {
          inSection = false;
          if (line == firstmatch) inSection = true;
        }
        
        if (inSection && string rest = line.startsWith "map_Kd ") fname = rest;
      }
      if (!fname) {
        writeln "No texture found for $matname! ";
        return null;
      } else {
        auto data = readImage fname;
        // writeln "Read image: $matname => $fname";
        matcache ~= (matname, data);
        return data;
      }
    }
    
    string[] selectAs(string delegate(string) dg) {
      string[auto~] res;
      for auto line <- obj if auto thing = dg line res ~= thing;
      return res[];
    }
    string[] selectOn(bool delegate(string) dg) {
      string[auto~] res;
      for auto line <- obj if dg line res ~= line;
      return res[];
    }
    vec3f vec3f_and_free(float[] array) { onSuccess array.free; return vec3f(array[(0, 1, 2)]); }
    vec2f vec2f_and_free(float[] array) { onSuccess array.free; return vec2f(array[(0, 1)]); }
    auto vertices = [for array <- [auto~for v <- selectAs(delegate string(string s) return s.startsWith "v ";): [auto~for part <- v.split " ": std.string.atof part].eval[]]: vec3f_and_free array].eval[];
    auto texcoords = [for array <- [auto~for v <- selectAs(delegate string(string s) return s.startsWith "vt ";): [auto~for part <- v.split " ": std.string.atof part].eval[]]: vec2f_and_free array].eval[];
    onSuccess { vertices.free; texcoords.free; }
    auto fusemtl = selectOn(delegate bool(string s) return eval s.startsWith "f " || s.startsWith "usemtl "; );
    Texture* currentTexture;
    auto currentSet = new TriangleSet;
    void flush() {
      // writeln "aabb = $(currentSet.root.aabb.a), $(currentSet.root.aabb.b)";
      if (currentSet.root.aabb.a.y < lowest) lowest = currentSet.root.aabb.a.y;
      currentSet.optimize;
      // writeln "Tree optimized";
      list ~= currentSet;
      bb.addBox(currentSet.root.aabb.(a, b));
      currentSet = new TriangleSet;
    }
    for auto line <- fusemtl {
      if auto rest = line.startsWith "f " {
        auto poly = rest.split " ";
        if (poly.length > 2)::
        auto tupAndFree(string[] st) { onSuccess st.free; return st[(0, 1)]; }
        if (rest.find("/")) {
          auto indices = [for
            pair <- [for pair <- [for part <- poly: tupAndFree part.split "/"]: (std.string.atoi pair[0] - 1, std.string.atoi pair[1] - 1)]:
            (vertices[pair[0]], texcoords[pair[1]])
          ].eval[];
          for (int i = 2; i < poly.length; ++i)
            currentSet.addTriangle (indices[(0, i, i-1)], currentTexture);
          if (currentSet.root.info.length > 1024)
            flush;
          indices.free;
        } else {
          auto indices = [for
            id <- [for index <- poly: std.string.atoi index - 1]:
            vertices[id]
          ].eval[];
          for (int i = 2; i < poly.length; ++i)
            currentSet.addTriangle (indices[0], vec2f(0), indices[i], vec2f(0), indices[i-1], vec2f(0), currentTexture);
          if (currentSet.root.info.length > 1024)
            flush;
          indices.free;
        }
        poly.free;
      }
      if auto rest = line.startsWith "usemtl " {
        currentTexture = lookupMatl rest;
      }
    }
    flush;
    obj.free;
    mtl.free;
    writeln "$(that.list.length) sub-objects";
    // writeln "$(infos.length) tris. ";
    object = bb;
  }
  
  fov = 1.1;
  
  using new Group {
    list ~= new Scale(1/4.0, new CheckerPattern(vec3f(1, 0.9, 0.6), vec3f(0.6, 0.9, 1), new Plane(vec3f(0, 1, 0), vec3f(0, 0, 0))));
    list ~= new EnvMap (readImage "OpenfootageNET_Beach_CavalinoItalylow.hdr", 1_000_000);
    // list ~= new Shine(vec3f(1), new Plane(vec3f(0, -1, 0), vec3f(0, 100, 0)));
    list ~= new CheckerPattern(vec3f(1, 0.9, 0.6), vec3f(0.6, 0.9, 1), new Plane(vec3f(0, 1, 0), vec3f(0, 0, 0)));
    // list ~= new Translate(vec3f(1, -lowest / 25, 5), new Scale(vec3f(-1/25.0, 1/25.0, -1/25.0), object));
    list ~= new Translate(vec3f(1, -lowest * 2, 1), new Scale(vec3f(2.5), object));
    scene = that;
  }
  
  using new Group {
    list ~= new Plane(vec3f(0, 1, 0), vec3f(0, 0, 0));
    list ~= new Shine(vec3f(1), new Plane(vec3f(0, -1, 0), vec3f(0, 10, 0)));
    list ~= new Color(vec3f(1, 0.7, 0.7) * 5, new Plane(vec3f(1, 0, 0), vec3f(-8, 0, 0)));
    // scene = that;
  }
  
  if (break-on-float-errors)
    for auto val <- [FE_DIVBYZERO, FE_INVALID/*, FE_OVERFLOW I said infs are fine >_>*/]
      feenableexcept val;
  
  float ratio = 1;
  if (imgres[0]) ratio = imgres[0] * 1f / imgres[1];
  
  (int, int) desired-display-size;
  if (imgres[0] && imgres[1]) desired-display-size = imgres;
  
  getScale = \() -> 2.0f * vec2f(ratio, 1) / vec2f(desired-display-size);
  // if (jitter) {
    // scene = new AverageResults(samples, new JitterRay(&getScale, new PathTraceLighting(scene, new PathTraceLighting (scene, new PathTraceLighting scene))));
  // } else {
    // scene = new PathTraceLighting(samples, scene, new PathTraceLighting (scene, new PathTraceLighting scene));
  // }
  scene = new MetropolisLighting(scene, depth, samples);
  
  vec4f[] resbuffer;
  
  VMStats stats;
  stats.needsRay;
  auto stream = scene.buildCommandStream(&stats);
  stream ~= CommandHandler: null; // terminator
  int rays-needed = stats.rays-needed-max;
  int results-needed = stats.results-needed-max;
  writeln "(ray, res): ($rays-needed, $results-needed): $(stream[0..$-1].length)";
  writeln "steps: $(stream.length - 1)";
  if (stream.length > 21) writeln "Last 20: $(stream[$-21..$-1])";
  else writeln "Stream: $(stream[0..$-1])";
  
  auto start = sec(), firststart = start;
  int iters; long rays;
  
  int xgroupsize = groupsize * stepsize;
  auto ray-res-vm-map = new (Ray[], Result[], VMState[])[] threads;
  void* align16(void* v) { return void*:(int:v + 15 #&-16); }
  void render(int thread, int id) {
    (dw, dh) = desired-display-size;
    alias my-ray-map = ray-res-vm-map[thread][0];
    alias my-res-map = ray-res-vm-map[thread][1];
    alias my-vm-map = ray-res-vm-map[thread][2];
    int count = groupsize;
    
    int from = id * xgroupsize, to = (id+1) * xgroupsize;
    
    using scoped recordResultDg::
    recordResultDg = delegate void(Ray* rayp, vec3f col, bool isBack, float factor, bool isMetroHit) {
      ray_to_coords(dw, dh, rayp, &int x, &int y);
      
      auto i = y * dw + x;
      if (i >= dw*dh || i < 0) return;
      auto colf = value(col, isBack);
      float icolf;
      
      if (colf * factor < float combinedFactor = minBrightnessFactor / markovSteps) {
        icolf = factor / combinedFactor; // bound
      } else {
        icolf = 1 / colf;
      }
      auto rbp = &resbuffer[i];
      alias rb = *rbp;
      auto coln = col * icolf;
      // writeln "record @$((x, y)): $(vec4f(coln.(x, y, z, icolf))) for $(col)";
      // writeln "at $((x, y)), record $(vec4f(coln.(x, y, z, icolf))) for $(col), adding to $(rb)";
      if (x == dbgPos[0] && y == dbgPos[1]) {
        writeln "at $((x, y)), record $(vec4f(coln.(x, y, z, icolf))) for $(col), adding to $(rb)";
      }
      rb += vec4f(coln.(x, y, z, icolf)) * factor;
    };
    // split into subfunctions for the benefit of the profiler.
    void setup() {
      auto xstream = stream;
      int resn = results-needed, rayn = rays-needed;
      // prealloc vm, results, rays
      if (my-vm-map.length != count + 1) {
        my-vm-map.free;
        my-vm-map = new VMState[] (count + 1);
      }
      if (my-ray-map.length != count * rayn + 1) {
        my-ray-map.free;
        my-ray-map = new Ray[] (count*rayn + 1);
      }
      if (my-res-map.length != count * resn + 1) {
        my-res-map.free;
        my-res-map = new Result[] (count*resn + 1);
      }
      Ray[] ray-slab = Ray*:align16(my-ray-map.ptr) #[0..my-ray-map.length - 1];
      Result[] res-slab = Result*:align16(my-res-map.ptr) #[0..my-res-map.length - 1];
      
      auto state = VMState*:align16(my-vm-map.ptr);
      
      rayplanes = null;
      resplanes = null;
      for 0..resn {
        resplanes ~= res-slab.ptr; res-slab = res-slab[count .. $];
      }
      for 0..rayn {
        rayplanes ~= ray-slab.ptr; ray-slab = ray-slab[count .. $];
      }
      int i;
      for (int k <- from..to) {
        if (++i == stepsize)::
        i = 0;
        int x = k % dw, y = k / dw;
        // float fx = x / (dw/2f) - 1f, fy = 1f - y / (dh/2f);
        using state {
          // result-id = 0;
          // ray-id = 1;
          // auto dir = vec3f(fx, fy, 1);
          // dir /= vec3f(|dir|);
          // ray.pos = vec3f(0, 2, 0);
          // ray.dir = dir;
          stream = xstream;
          cached = false;
          state = 0;
          state2 = 0;
          burnInCounter = burnInLimit; // for mlt
        }
        state ++;
      }
      fastsetup(rayplanes.ptr, from, to, dw, dh, stepsize, align16(&my-vm-map[0]));
    }
    void process() {
      check;
      auto rayqueue = VMState*:align16(my-vm-map.ptr) #[0..my-vm-map.length - 1];
      // writeln "PROCESS";
      // This MUST proceed backwards! The handlers use i as index into the planes!
      do {
        while (rayqueue.length && !rayqueue[$-1].handler) rayqueue = rayqueue[0 .. $-1];
      } while (rayqueue.length) {
        auto hdl = rayqueue[$-1].stream.ptr;
        // for int i <- 0..rayqueue.length if int:rayqueue[i].stream.ptr < int:hdl hdl = rayqueue[i].stream.ptr;
        // int num;
        // for auto rq <- rayqueue if int:rq.handler == int:*hdl num++;
        // writeln "$(*hdl): $num out of $(rayqueue.length)";
        hdl.process rayqueue;
      }
      // writeln "END";
    }
    setup();
    process();
  }
  
  auto lp = new LoopPool threads;
  
  // debug code
  // imgres[(0, 1)] = (80, 60);
  // desired-display-size = imgres;
  
  if (imgres[0] && imgres[1]) {
    
    resbuffer = new vec4f[] (imgres[0] * imgres[1]);
    resbuffer[] = [for 0..resbuffer.length: vec4f.W];
    
    auto surf = screen(imgres, surface => true);
    writeln "Calculate $(imgres). ";
    bool done; int parts-done;
    dw = imgres[0]; dh = imgres[1];
    void saveAs(string file, bool finalCall = false) {
      float avg_w = 0; int sum;
      for (int k <- 0..dw*dh) {
        if (resbuffer[k].(w != 1 && w > 0)) {
          avg_w += resbuffer[k].w;
          sum ++;
        }
      }
      avg_w /= sum;
      /*float max_x = 0;
      for (int k <- 0..dw*dh) {
        if (auto x = resbuffer[k].x) > max_x max_x = x;
      }
      if (max_x == 0f) max_x = 1;*/
      if (file.endsWith(".hdr")) {
        auto colbuffer = new vec3f[] (dw * dh);
        if (average) {
          for (int k <- 0..dw*dh) {
            colbuffer[k] = resbuffer[k].(xyz/avg_w);
          }
        } else {
          for (int k <- 0..dw*dh) {
            colbuffer[k] = resbuffer[k].(xyz/w);
          }
        }
        auto data = encodeHDR(colbuffer, dw, dh);
        colbuffer.free;
        writeAll(file, data);
        data.free;
        return;
      }
      auto gdp = gdImageCreateTrueColor(imgres);
      onSuccess gdImageDestroy gdp;
      for (int k <- 0..dw*dh) {
        vec3f col;
        if (average) {
          col = resbuffer[k].(xyz/avg_w);
        } else {
          col = resbuffer[k].(xyz/w);
        }
        float maxf(float a, b) return [a, b][b > a];
        if (col.(maxf(x, maxf(y, z))) > 1)
          col /= col.(maxf(x, maxf(y, z)));
        // col = resbuffer[k].xxx / max_x;
        int x = k % dw, y = k / dw;
        gdp.tpixels[y][dw - 1 - x] = floatToIntColor col;
      }
      auto hdl = fopen (file.toStringz(), "w");
      gdImagePng(gdp, c.gd.FILE*: hdl);
      fclose hdl;
    }
    int framenum;
    void save(bool finalCall = false) {
      if (saveFrames && !finalCall) {
        string framestr = "$framenum";
        while (framestr.length < 5) framestr = "0$framestr";
        saveAs(file.between_r("", ".")~".$framestr."~file.between_r(".", ""));
        framenum ++;
      }
      saveAs(file, finalCall);
    }
    (auto up = new ThreadPool 1).addTask delegate void() {
      auto start = sec();
      while !done {
        auto t = sec(), delta = float:(t - start);
        if (parts-done) {
          int num-parts = (dw * dh) / xgroupsize;
          writeln "$(int:delta)s: $(parts-done * 100 / num-parts)% done, est. $(int:(delta * num-parts / parts-done - delta))s left. ";
        }
        save();
        sleep savestep;
      }
    };
    int len = (imgres[0] * imgres[1]) / xgroupsize;
    int[] randmap = [for i <- 0..len: i].eval[];
    for int i <- 0..len swap randmap[i], randmap[i..$][rand()%$]; // fisher-yates shuffle
    lp.runLoop(len, delegate void(int id, thr) { render(thr, id/*randmap[id]*/); parts-done ++; });
    done = true;
    up.waitComplete;
    writeln "Save. (processed $c__3, succeeded $c__ - registered $c__2)";
    save(true);
    return;
  }
  
  auto resbuffer-lock = new ReadWriteLock;
  
  auto surf = screen(512, 300, surface => true);
  desired-display-size = surf.(w, h);
  
  resbuffer = new vec4f[] surf.(w * h);
  resbuffer[] = [for 0..resbuffer.length: vec4f.W];
  
  onResize(800, 800);
  bool stop;
  using new ThreadPool 1::
  addTask delegate void() {
    auto last-printed = sec();
    while !stop {
      resbuffer-lock.lock-read();
        auto rdg = &render;
        auto ddsx = desired-display-size[0], ddsy = desired-display-size[1], xgroupsize = xgroupsize;
        int total = (ddsx * ddsy) / xgroupsize;
        lp.runLoop(total, delegate void(int id, thr) { rdg(thr, id); });
      resbuffer-lock.unlock();
      iters ++;
      rays += surf.(w*h);
      // render();
      auto delta = float:(sec() - start);
      auto fulldelta = float:(sec() - firststart);
      float fps;
      if (delta > 0) fps = iters / delta;
      else fps = 0.001; // eps
      // reconfigure window size to reach target fps
      float pixelfactor = desired-fps / fps, psq = sqrtf pixelfactor;
      float absf(float f) { if (f < 0) return -f; return f; }
      if (float:(sec() - last-printed) > 5) {
        writeln "[fps $fps] [wanted $desired-fps] [res $desired-display-size] [speed $(surf.(w*h) * iters / delta / 1_000_000)mrps] [full speed $(double:rays / fulldelta / 1_000_000)mrps]";
        last-printed = sec();
      }
      if (absf (pixelfactor - 1) > 0.05 && delta > 1) {
        if (psq < 0.7) psq = 0.7;
        (int, int) updated-size = (int:(surf.w / psq), int:(surf.h / psq));
        updated-size = (updated-size[0] / 10 #* 10, updated-size[1] / 10 #* 10);
        if (updated-size[0] != desired-display-size[0] && updated-size[1] != desired-display-size[1]) {
          resbuffer-lock.lock-write();
            desired-display-size = updated-size;
            resbuffer.free;
            resbuffer = new vec4f[] (updated-size[0] * updated-size[1]);
            resbuffer[] = [for 0..resbuffer.length: vec4f.W * 0.0001]; // so that xyz/w doesn't error
          resbuffer-lock.unlock();
        }
        // reset estimation
        iters = 0; start = sec();
      }
    }
  };
  set-handler(Error err) {
    writeln "$err. Exiting. ";
    invoke-exit "main-return";
  }
  define-exit "main-return" {
    stop = true;
    waitComplete;
    return;
  }
  auto begin = sec();
  int tex;
  glGenTextures(1, &tex);
  onSuccess glDeleteTextures(1, &tex);
  while (true) {
    auto start-draw = sec();
    resbuffer-lock.lock-read();
    dw = surf.w; dh = surf.h;
    for (int k <- 0..dw*dh) {
      auto col = resbuffer[k].(xyz/w);
      float maxf(float a, b) return [a, b][b > a];
      if (col.(maxf(x, maxf(y, z))) > 1)
        col /= col.(maxf(x, maxf(y, z)));
      int x = k % dw, y = k / dw;
      surf.pset(x, y, col);
    }
    resbuffer-lock.unlock();
    mode GL {
      Viewport (0, 0, display.(w, h));
      MatrixMode PROJECTION;
      LoadIdentity;
      MatrixMode MODELVIEW;
      LoadIdentity;
      using TEXTURE_2D {
        Enable;
        BindTexture tex;
        TexParameteri(TEXTURE_MIN_FILTER, NEAREST);
        TexParameteri(TEXTURE_MAG_FILTER, NEAREST);
        TexImage2D (0, 3, surf.(w, h), 0, 0x80E1 /*BGRA*/, UNSIGNED_BYTE, surf.surf.back.pixels);
      }
      ClearColor (1, 1, 0, 0);
      Clear (COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT);
      
      using Quads {
        Vertex2f( 1, -1); TexCoord2f(0, 0);
        Vertex2f( 1,  1); TexCoord2f(1, 0);
        Vertex2f(-1,  1); TexCoord2f(1, 1);
        Vertex2f(-1, -1); TexCoord2f(0, 1);
      }
    }
    surf.surf.flip;
    SDL_GL_SwapBuffers();
    flip;
    if (mouse-clicked) writeln "click: $(mouse-pos)";
    auto end-draw = sec();
    auto should-take = 1f / desired-fps, delta = should-take-end-draw+start-draw /* abusive */;
    if (should-take > 0)
      sleep should-take;
    if (surf.(w != desired-display-size[0] || h != desired-display-size[1])) {
      surf = screen (desired-display-size, surface => true);
    }
  }
}
