module scene.sphere;

import scene.base;

extern(C) void fast_sphere_process(VMState*, int numstates, vec3f center, float rsq, void* self);

class Sphere : SceneObject {
  vec3f center;
  float radius, rsq;
  void init(vec3f c, float r) { center = c; radius = r; rsq = radius * radius; }
  bool collide(Ray* ray, Result* res) {
    vec3f pos = ray.pos - center; // pretranslate so we can pretend that we're a sphere around the origin
    vec3f dir = ray.dir;
    float p = lvize(vec3f(2) * pos * dir).sum;
    
    float inside = (p*p/4 + rsq) - lvize(pos*pos).sum;
    if (inside < 0) return false;
    
    float sq = sqrtf inside,
      k = -p/2,
      k1 = k + sq,
      k2 = k - sq;
    if (k1 < 0) return false;
    res.distance = [k1, k2][eval k2 > 0];
    res.col = vec3f(1);
    {
      vec3f normal = ray.(pos + dir * res.distance) - center;
      res.normal = normal / vec3f(|normal|);
    }
    return true;
  }
  void process(VMState[] list) {
    fast_sphere_process(list.ptr, list.length, center, rsq, void*:CommandHandler:this);
    return;
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(allocResult);
      vec3f pos = sp.ray.pos;
      pos -= center; // pretranslate so we can pretend that we're a sphere around the origin
      vec3f dir = sp.ray.dir;
      
      auto res = sp.result;
      
      float rsq = rsq;
      // algorithm 1 - benchs as FASTER!!
      float k = -(dir * pos).sum / (dir*dir).sum;
      auto p = pos + dir * k, ps = (p*p).sum;
      if (ps > rsq) { res.success = false; }
      else::
      
      auto sq = sqrtf (rsq - ps);
      auto k1 = k + sq, k2 = k - sq;
      
      // algorithm 2
      /*float p = lvize(vec3f(2) * pos * dir).sum;
      
      float inside = (p*p/4 + rsq) - lvize(pos*pos).sum;
      if (inside < 0) { res.success = false; }
      else::
      
      float sq = sqrt inside,
        k = -p/2,
        k1 = k + sq,
        k2 = k - sq;*/
      
      // common
      if (k1 < 0) { res.success = false; }
      else using res::
      success = true;
      
      distance = [k1, k2][eval k2 > 0];
      col = vec3f(1);
      vec3f normal = sp.ray.(pos + dir * distance) - center;
      that.normal = normal / vec3f(|normal|);
    }
  }
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.results-needed-cur ++;
    return CommandHandler[]: null ~ this;
  }
}
