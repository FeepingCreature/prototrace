module scene.triangle;

import scene.base, scene.texture;

class Triangle : SceneObject {
  vec3f a, ba, ca, n;
  void init(vec3f a, b, c) {
    this.(a, ba, ca) = (a, b - a, c - a);
    n = vec3f(
      ba.y*ca.z - ba.z*ca.y,
      ba.z*ca.x - ba.x*ca.z,
      ba.x*ca.y - ba.y*ca.x
    );
  }
  bool collide(Ray* ray, Result* res) {
    vec3f normal = n.normalized;
    float dist = -(normal * (ray.pos - a)).sum / (ray.dir * normal).sum;
    if (dist < 0) return false;
    auto p = ray.pos + ray.dir * dist;
    // thanks, http://www.blackpawn.com/texts/pointinpoly/default.html !
    xmm[4] = ca;
    xmm[5] = ba;
    xmm[6] = p - a;
    alias v0 = xmm[4], v1 = xmm[5], v2 = xmm[6];
    float
      dot00 = v0 * v0 #.sum,
      dot01 = v0 * v1 #.sum,
      dot02 = v0 * v2 #.sum,
      dot11 = v1 * v1 #.sum,
      dot12 = v1 * v2 #.sum;
    float invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    if (u < 0 || v < 0 || u+v > 1) return false;
    res.distance = dist;
    res.col = vec3f(1);
    res.normal = normal;
    return true;
  }
  void process(VMState[] list) {
    vec3f normal = n.normalized;
    xmm[4] = ca;
    xmm[5] = ba;
    alias v0 = vec3f:xmm[4], v1 = vec3f:xmm[5];
    float
      dot00 = v0 * v0 #.sum,
      dot01 = v0 * v1 #.sum,
      dot11 = v1 * v1 #.sum;
    float invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
    
    for (int i = 0; i < list.length; ++i) {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto pos = sp.ray.pos, dir = sp.ray.dir;
      using sp mixin(allocResult);
      auto res = sp.result;
      
      float dist = -(normal * (pos - a)).sum / (dir * normal).sum;
      if (dist < 0) res.success = false;
      else {
        auto p = pos + dist * dir;
        
        xmm[6] = p - a;
        alias v2 = vec3f:xmm[6];
        
        float
          dot02 = v0 * v2 #.sum,
          dot12 = v1 * v2 #.sum;
        
        float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // writeln "$u, $v";
        
        if (u > 0 && v > 0 && u + v < 1) {
          res.(success, distance, col, emissive-color, normal)
            = (true,    dist,vec3f(1), vec3f(0),       normal);
        } else {
          res.success = false;
        }
      }
    }
  }
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.results-needed-cur ++;
    return CommandHandler[]:null ~ this;
  }
}

struct TriangleInfo {
  vec3f a, b, c, n;
  vec2f uv-a, uv-ba, uv-ca;
  float invDenom; Texture* texture-state;
}

extern(C) int fast_rayHitsAABB(vec3f* abp, p_ray, float* dist);

struct AABB {
  vec3f a, b;
  void addInitialPoint(vec3f v) { 
    a = v; b = v;
  }
  void addPoint(vec3f v) {
    for int i <- 0..3 {
      a[i] = min(a[i], v[i]);
      b[i] = max(b[i], v[i]);
    }
  }
  bool rayHits(vec3f* ray-p, (float, float)* dist = null) {
    // return rayHitsAABB(&a, &b, pos-p, dir-p, dist);
    float f;
    auto res = fast_rayHitsAABB(&a, ray-p, &f);
    if (dist) { *dist = (f, 1); }
    return res;
  }
  bool rayHits_unaligned(vec3f* pos-p, dir-p, (float, float)* dist = null) {
    vec3f pos = pos-p[0], dir = pos-p[1];
    vec3f a = void, b = void;
    a = this.a; b = this.b;
    float f;
    auto res = fast_rayHitsAABB(&a, &pos, &f);
    if (dist) { *dist = (f, 1); }
    return res;
  }
}

extern(C) int posix_memalign(void**, size_t, size_t);
extern(C) void* GC_memalign(size_t, size_t);
extern(C) void* memset(void*, int, int);
void* aligned_calloc(int i) {
  void* res;
  // posix_memalign(&res, size_t:16, size_t:i);
  res = GC_memalign(size_t:16, size_t:i);
  memset(res, 0, i);
  return res;
}

int round16(int i) { return (i + 15) &-16; }

struct TriangleNode {
  AABB aabb;
  TriangleNode*[] children;
  TriangleInfo[auto~] info;
  alias left = children[0], right = children[1];
  
  // return void*:size if slab is null, res otherwise
  void validate() {
    if (children.length > 4) {
      writeln "Invalid children-array: $(children.(length, ptr))";
      _interrupt 3;
    }
    if (info.length > 100_000 || info.length < 0) {
      writeln "Invalid info-array: $(info.(length, ptr))";
      _interrupt 3;
    }
    for auto ch <- children ch.validate;
  }
  void* linearAllocate(void** slabp = null) {
    if (size-of TriangleInfo & 15) { writeln "WTF! :( $(size-of TriangleInfo) => $(size-of TriangleInfo & 15)"; _interrupt 3; }
    alias slab = *slabp;
    if (slabp) {
      auto res = TriangleNode*:slab;
      slab = void*:round16(int:slab + size-of TriangleNode);
      res.aabb = aabb;
      if (children.length) {
        res.children = TriangleNode**:slab #[0..children.length];
        slab = void*:round16(int:slab + children.length * size-of TriangleNode*);
        for int i <- 0..children.length {
          res.children[i] = children[i].linearAllocate &slab;
        }
      } else {
        res.info = TriangleInfo*:slab #[0..info.length];
        slab += info.length * size-of TriangleInfo;
        for int i <- 0..info.length
          res.info[i] = info[i];
        info.free;
      }
      return res;
    } else {
      if (children.length) {
        int s;
        for auto ch <- children s += int:ch.linearAllocate();
        return void*:(round16 size-of TriangleNode + round16 (children.length * size-of TriangleNode*) + s);
      } else {
        return void*:(round16 size-of TriangleNode + info.length * size-of TriangleInfo);
      }
    }
  }
  void free() {
    if (children.length) { for auto ch <- children ch.free; }
    else info.free;
  }
  void addTriangle(TriangleInfo* ti) {
    if (!info.length) aabb.addInitialPoint ti.a;
    else aabb.addPoint ti.a;
    
    info ~= *ti;
    
    aabb.addPoint ti.b;
    aabb.addPoint ti.c;
  }
  TriangleNode* trySplitTris(int axis) {
    auto res = TriangleNode*:aligned_calloc size-of TriangleNode;
    res.aabb = aabb;
    
    auto left = TriangleNode*:aligned_calloc size-of TriangleNode;
    auto right = TriangleNode*:aligned_calloc size-of TriangleNode;
    res.children = TriangleNode**:aligned_calloc (2 * size-of TriangleNode*) #[0..2];
    res.children[0] = left;
    res.children[1] = right;
    
    auto marker = aabb.(a[axis] + (b[axis] - a[axis]) * 0.5);
    for auto tri <- [for i <- 0..info.length: &info[i]] {
      if (tri.a[axis] < marker || tri.b[axis] < marker || tri.c[axis] < marker)
        left.addTriangle tri;
      if (tri.a[axis] >= marker || tri.b[axis] >= marker || tri.c[axis] >= marker)
        right.addTriangle tri;
    }
    return res;
  }
  TriangleNode* split() {
    TriangleNode* x 3 tns;
    tns[0] = trySplitTris(0);
    tns[1] = trySplitTris(1);
    tns[2] = trySplitTris(2);
    
    int x 3 perf;
    for int i <- 0..3 {
      perf[i] = tns[i].left.info.length + tns[i].right.info.length;
    }
    
    auto il = info.length;
    int bestChoice = -1;
    if (tns[0].(left.info.length != il && right.info.length != il)) bestChoice = 0;
    if (tns[1].(left.info.length != il && right.info.length != il) && (bestChoice == -1 || perf[1] < perf[bestChoice]))
      bestChoice = 1;
    if (tns[2].(left.info.length != il && right.info.length != il) && (bestChoice == -1 || perf[2] < perf[bestChoice]))
      bestChoice = 2;
    if (bestChoice == -1) { for int i <- 0..3 tns[i].free; return null; }
    auto res = tns[bestChoice];
    for int i <- 0..3 if i != bestChoice tns[i].free;
    return res;
  }
  void splitreplace() {
    auto res = split();
    if (!res) return;
    float eff = (info.length * 1f / (res.right.info.length + res.left.info.length)) - 0.5 #* 2f;
    if (eff < 0.6) { res.free; return; } // not worth it? HEURISTIC. See perf.txt
    // writeln "$(info.length) => $(left.info.length), $(right.info.length): efficiency of $(int:(eff*100))%";
    children = res.children;
    info.free;
    left .splitreplace();
    right.splitreplace();
  }
}

extern(C) void fast_triangle_recurse(TriangleNode *node, vec3f* pos, dir, TriangleInfo** closest_res, float* closest, vec2f* uv);

class TriangleSet : SceneObject {
  TriangleNode* root;
  void init() { root = new TriangleNode; }
  void addTriangle(vec3f a, vec2f atex, vec3f b, vec2f btex, vec3f c, vec2f ctex, Texture* texptr) {
    TriangleInfo ti;
    ti.(a, b, c, uv-a, uv-ba, uv-ca) = (a, b, c, atex, btex - atex, ctex - atex);
    ti.texture-state = texptr;
    auto ba = b - a, ca = c - a;
    ti.n = ti.(vec3f(
      ba.y*ca.z - ba.z*ca.y,
      ba.z*ca.x - ba.x*ca.z,
      ba.x*ca.y - ba.y*ca.x
    ));
    if (ti.n == vec3f(0)) ti.n = vec3f.Y;
    ti.n = -ti.n.normalized;
    
    float dot00 = ca * ca #.sum;
    float dot01 = ca * ba #.sum;
    float dot11 = ba * ba #.sum;
    // precompute
    float denom = dot00 * dot11 - dot01 * dot01;
    if (denom != 0) ti.invDenom = 1 / denom;
    else ti.invDenom = 1;
    
    root.addTriangle &ti;
  }
  void flatten() {
    auto size = int:root.linearAllocate();
    // writeln "full slab size = $size";
    void* ptr = aligned_calloc size;
    root = TriangleNode*: root.linearAllocate(&ptr);
  }
  void optimize() {
    root.splitreplace(2);
    // four children is always better than two assuming ray isn't a total miss
    // ray is total miss: 2 tests => 4 tests
    // ray hits one child: 2 tests + 2 at the next level = 4 tests => 4 tests
    // ray hits both children: 2 tests + 4 at the next level = 6 tests => 4 tests
    void two_to_four(TriangleNode* tnode) {
      if (tnode.(children.length == 2 && children[0].children.length == 2 && children[1].children.length == 2)) {
        auto newchildren = TriangleNode**:aligned_calloc (4 * size-of TriangleNode*) #[0..4];
        for (int i1, (int i2, int i3)) <- zip(0..4, cross(0..2, 0..2))
          newchildren[i1] = tnode.children[i2].children[i3];
        tnode.children = newchildren;
      }
      for auto ch <- tnode.children two_to_four ch;
    }
    // may not be worth it .. test more?
    // two_to_four root;
    flatten;
  }
  bool collide(Ray* ray, Result* res) { _interrupt 3; }
  void process(VMState[] list) {
    for (int i = 0; i < list.length; ++i) {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(allocResult);
      auto res = sp.result;
      
      res.success = false;
      
      auto pos = sp.ray.pos, dir = sp.ray.dir;
      
      float closest; TriangleInfo* closest-info;
      vec2f texcoord;
      void recurse(TriangleNode* node) {
        if (node.children.length) {
          if (closest-info) {
            (float, float) fs;
            alias fdist = fs[0] / fs[1];
            for auto ch <- node.children
              if (ch.aabb.rayHits(&pos, &fs) && fdist < closest) recurse(ch);
          } else {
            for auto ch <- node.children
              if (ch.aabb.rayHits(&pos)) recurse(ch);
          }
        } else {
          auto trilist = node.info[];
          for auto ti <- [for i <- 0..trilist.length: &trilist[i]] {
            float f1 = (ti.n * (pos - ti.a)).sum;
            float f2 = (dir * ti.n).sum;
            if (f2 != 0) ::
            float dist = - f1 / f2;
            if (dist > 0)::
            if (!closest-info || dist < closest):: // no point otherwise
            auto p = pos + vec3f(dist) * dir;
            xmm[7] = ti.a;
            xmm[4] = ti.c; xmm[4] -= xmm[7];
            xmm[5] = ti.b; xmm[5] -= xmm[7];
            xmm[6] =    p; xmm[6] -= xmm[7];
            alias v0 = xmm[4], v1 = xmm[5], v2 = xmm[6];
            float
              dot00 = v0 * v0 #.sum,
              dot01 = v0 * v1 #.sum,
              dot02 = v0 * v2 #.sum,
              dot11 = v1 * v1 #.sum,
              dot12 = v1 * v2 #.sum;
            float invDenom = ti.invDenom;
            
            float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
            if (u >= 0 && v >= 0 && u+v <= 1) {
              closest-info = ti;
              closest = dist;
              texcoord = vec2f(u, v);
            }
          }
        }
      }
      fast_triangle_recurse(root, &pos, &dir, &closest-info, &closest, &texcoord);
      // recurse root;
      
      if (closest-info) {
        texcoord = closest-info.(uv-a + texcoord.x * uv-ca + texcoord.y * uv-ba);
        res.(success, distance, col,      emissive-color, normal,         texcoord, texinfo)
          = (true,    closest,  vec3f(1), vec3f(0),       closest-info.n, texcoord, closest-info.texture-state);
        if (closest-info.texture-state)
          res.col = interpolate(texcoord.(x, 1-y), closest-info.texture-state);
      }
    }
  }
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.results-needed-cur ++;
    return CommandHandler[]:null ~ this;
  }
}
