module scene.util;

import std.random, std.thread;

import scene.base;

alias EPS = 0.999;

shared int c__, c__2, c__3;

shared int dw, dh;

shared vec2f delegate() getScale;

IRandom rng;
float randf() { return std.random.base.randf(rng); }
int rand() { return rng.rand(); }
void init() {
  rng = getPRNG(23);
  auto dg = onThreadCreation;
  onThreadCreation = new delegate void(void* basep) {
    if (dg) { dg(basep); }
    rng = getPRNG(int:basep);
  };
}

vec3f rand_sphere() {
  vec3f res;
  float magn;
  do {
    res = vec3f((randf() * 2 - 1) x 3);
    magn = |res|;
  } while magn > 1 { }
  return res / magn;
}

(float, float) vary(float x, y, int spread) {
  float randf2() {
    alias shift = -2;
    float f = (randf() - 0.5) * 2 * spread;
    if (f < 0) return -pow(2, -f + shift);
    else       return  pow(2, f + shift);
  }
  return (x+randf2(), y+randf2());
}

class AverageStep : CommandHandler {
  int count;
  int dst, src; // average src into dst
  void init(int c, dst, src) { this.(count, dst, src) = (c, dst, src); }
  void process(VMState[] list, int start, end) {
    float factor = 1f / count;
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto res1 = &resplanes[dst][i], res2 = &resplanes[src][i];
      vec3f sum = vec3f(0);
      if (res1.success) sum = res1.emissive-color;
      if (res2.success) sum += res2.emissive-color * factor;
      res1.success |= res2.success;
      res1.emissive-color = sum;
    }
  }
}

class AllocEmptyResult : CommandHandler {
  void process(VMState[] list, int start, end) {
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(allocResult);
      resplanes[sp.result-id-1][i].success = false;
    }
  }
}

class FreeResult : CommandHandler {
  void process(VMState[] list, int start, end) {
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(freeResult.replace("!!", "1"));
    }
  }
}

class AverageResults : SceneObject {
  SceneObject sup;
  int count;
  void init(int count, SceneObject sup) this.(sup, count) = (sup, count);
  CommandHandler[] buildCommandStream(VMStats* stats) {
    int base-id = stats.results-needed-cur;
    stats.needsResult;
    auto stream = sup.buildCommandStream(stats);
    stats.results-needed-cur --;
    
    auto as = new AverageStep (count, base-id, base-id + 1);
    auto fr = new FreeResult;
    
    CommandHandler[auto~] res;
    res ~= new AllocEmptyResult; // res ++
    for (int i = 0; i < count; ++i) {
      res ~= stream; // res ++
      res ~= as;
      res ~= fr; // res --
    }
    return res[];
  }
}

class FreeRay : CommandHandler {
  void process(VMState[] list, int start, end) {
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(freeRay.replace("!!", "1"));
    }
  }
}

class CopyRay : CommandHandler {
  int from;
  void init() { from = -1; }
  void init(int f) from = f;
  void process(VMState[] list, int start, end) {
    // TODO: memcpy runs
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      using sp mixin(allocRay);
      if (from == -1) {
        rayplanes[sp.ray-id - 1][i] = rayplanes[sp.ray-id - 2][i];
      } else {
        rayplanes[sp.ray-id - 1][i] = rayplanes[from][i];
      }
    }
  }
}

class SkipAhead : CommandHandler {
  int skipdist; void init(int i) skipdist = i;
  void process(VMState[] list, int start, end) {
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      sp.stream = sp.stream[skipdist .. $];
    }
  }
}

/*
class IfState : CommandHandler {
  int compare, skip; void init(int c, s) (compare, skip) = (c, s);
  void process(VMState[] list) {
    for int i <- 0 .. list.length {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      if (sp.state != compare) sp.stream = sp.stream[skip .. $];
    }
  }
}

CommandHandler[] mkIfElse(int compare, CommandHandler[] case1, case2) {
  CommandHandler[auto~] res;
  case1 ~= new SkipAhead(case2.length);
  res ~= new IfState(compare, case1.length);
  res ~= case1;
  res ~= case2;
  return res[];
}
*/

extern(C) {
  void ray_to_coordsf(int dw, dh, Ray* rayp, float* xp, yp);
  void coordsf_to_ray(int dw, dh, float x, y, Ray* rayp);
}

class RandomizeRay : CommandHandler {
  int src;
  void init(int src = -1) { this.src = src; }
  void process(VMState[] list, int start, end) {
    auto sc = getScale();
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      Ray* ray;
      if (src == -1) ray = &rayplanes[sp.ray-id-1][i];
      else ray = &rayplanes[src][i];
      
      using sp mixin(allocRay);
      
      auto nray = &rayplanes[sp.ray-id-1][i];
      
      float fx, fy;
      ray_to_coordsf(dw, dh, ray, &fx, &fy);
      // (fx, fy) = vary(fx, fy, 5);
      // fx += randf() - 0.5;
      // fy += randf() - 0.5;
      fx = randf() * dw;
      fy = randf() * dh;
      coordsf_to_ray(dw, dh, fx, fy, nray);
    }
  }
}

void delegate(Ray* rayp, vec3f col, bool isBack, float factor, bool isMetroHit) recordResultDg;

void recordState(VMState* sp, int i, int skipRays, skipResults, vec3f v, bool isBack, float bias) {
  bool record;
  bool isMetroHit = true;
  /*if (sp.burnInCounter > 0) sp.burnInCounter --;
  else */record = true;
  if (record) { c__2 ++; recordResultDg (&rayplanes[skipRays][i], v, isBack, bias, isMetroHit => isMetroHit); }
}

class RecordResultStep : CommandHandler {
  int skipRays, skipResults;
  void init(int skRay = 0, skRes = 0) (skipRays, skipResults) = (skRay, skRes);
  void process(VMState[] list, int start, end) {
    for int i <- start .. end {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto v = evaluateRay(sp, i, skipRays, skipResults, isBack => &bool b);
      recordState(sp, i, skipRays, skipResults, v, b, 1);
    }
  }
}
