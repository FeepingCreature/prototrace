module scene.plane;

import scene.base;

extern(C) void fast_plane_process(Ray**, Result**, VMState*, int numstates, vec3f normal, base, void* self);

class Plane : SceneObject {
  vec3f normal, base;
  void init(vec3f n, b) { normal = n; base = b; }
  bool collide(Ray* ray, Result* res) {
    float dist = -(normal * (ray.pos - base)).sum / (ray.dir * normal).sum;
    if (dist < 0) return false;
    res.distance = dist;
    res.col = vec3f(1);
    res.normal = normal;
    return true;
  }
  void process(VMState[] list) {
    // fast_plane_process(rayplanes.ptr, resplanes.ptr, list.ptr, list.length, normal, base, void*:CommandHandler:this);
    // return;
    for (int i = 0; i < list.length; ++i) {
      auto sp = &list[i];
      
      if (void*:sp.handler == void*:CommandHandler:this)::
      sp.stream = sp.stream[1..$];
      
      auto ray = &rayplanes[sp.ray-id-1][i];
      auto pos = ray.pos, dir = ray.dir;
      using sp mixin(allocResult);
      auto res = &resplanes[sp.result-id-1][i];
      float dist = -(normal * (pos - base)).sum / (dir * normal).sum;
      if (dist < 0) res.success = false;
      else {
        res.(success, distance, col, normal)
          = (true,    dist,vec3f(1), normal);
      }
    }
  }
  CommandHandler[] buildCommandStream(VMStats* stats) {
    stats.needsResult;
    return CommandHandler[]:null ~ this;
  }
}
